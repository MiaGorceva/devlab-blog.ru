<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ERP, которая не превращается в дорогой тормоз: ограничения 1С / SAP / Dynamics / Odoo – DevLab Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Технический разбор архитектурных ограничений ERP по мотивам статей на Хабре: где именно возникают ограничения 1С и как похожие точки проявляются в SAP / Dynamics / Odoo. Пункт-в-пункт, с практическими последствиями для изменений, контроля и сопровождения."
  />

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="https://uk.devlab.blog/img/devlab-logo.svg">
  <link rel="alternate icon" type="image/png" sizes="32x32" href="https://uk.devlab.blog/img/devlab-favicon-32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://uk.devlab.blog/img/devlab-favicon-180.png">

  <!-- Consent Mode (set BEFORE GTM) -->
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('consent','default',{
      analytics_storage:'denied',
      ad_storage:'denied',
      ad_user_data:'denied',
      ad_personalization:'denied',
      functionality_storage:'granted',
      security_storage:'granted'
    });
  </script>

  <!-- Main blog styles -->
  <link rel="stylesheet" href="https://uk.devlab.blog/style/devlab-style.css">

  <!-- Main blog scripts (year + search + views counter) -->
  <script src="https://uk.devlab.blog/js/script.js" defer></script>

  <!-- Structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://ru.devlab.blog/posts/post16-erp-change-friendly-architecture-compare.html"
    },
    "headline": "ERP, которая не превращается в дорогой тормоз: анализ архитектуры 1С / SAP / Dynamics / Odoo",
    "description": "Технический разбор архитектурных ограничений ERP по мотивам статей на Хабре: где именно возникают ограничения 1С и как похожие точки проявляются в SAP / Dynamics / Odoo. Пункт-в-пункт, с практическими последствиями для изменений, контроля и сопровождения.",
    "author": { "@type": "Organization", "name": "DevLab Blog" },
    "publisher": {
      "@type": "Organization",
      "name": "DevLab",
      "logo": { "@type": "ImageObject", "url": "https://uk.devlab.blog/img/devlab-logo.svg" }
    },
    "datePublished": "2026-01-22",
    "dateModified": "2026-01-22"
  }
  </script>

  <link rel="canonical" href="https://ru.devlab.blog/posts/post16-erp-change-friendly-architecture-compare.html">

  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WTZDV4K6');</script>
  <!-- End Google Tag Manager -->
</head>

<body class="post-page">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WTZDV4K6"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div class="page">
    <!-- HEADER -->
    <header>
      <div class="wrapper">
        <nav class="nav">
          <a href="/" class="nav-brand">
            <div class="nav-logo" aria-hidden="true">
              <img src="https://uk.devlab.blog/img/devlab-logo.svg" alt="DevLab Blog logo">
            </div>
            <div class="nav-meta">
              <div class="nav-meta-title">DevLab Blog</div>
              <div class="nav-meta-sub">Open-source ERP &amp; automation notes</div>
            </div>
          </a>

          <div class="nav-group">
            <div class="nav-links">
              <a href="/#posts">Статьи</a>
              <a href="/#categories">Категории</a>
              <a href="/#about">О блоге</a>
              <a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Главный сайт</a>
            </div>
            <div class="nav-lang">
              <a href="https://en.devlab.blog/">EN</a>
              <a href="https://pl.devlab.blog/">PL</a>
              <a href="https://ru.devlab.blog/" class="active">RU</a>
              <a href="https://uk.devlab.blog/">UA</a>
            </div>
          </div>

          <div class="nav-cta">
            <a href="/#posts" class="btn btn-outline">Все статьи</a>
            <a href="/#about" class="btn btn-primary">Что это?</a>
          </div>

          <button class="nav-toggle" aria-label="Toggle navigation">☰</button>
        </nav>
      </div>
    </header>

    <!-- MAIN -->
    <main>
      <div class="wrapper">
        <div class="main-grid">
          <!-- ARTICLE -->
          <article id="post16-erp-change-friendly-architecture-compare">
            <div class="section-title">
              <span>Статья</span>
              <small><a class="back" href="/">← Назад ко всем статьям</a></small>
            </div>

            <header>
              <div class="post-meta">
                <span>ERP · Архитектура · Сопровождение</span>
                <span>&middot;</span>
                <span>Примерно 10–12 мин чтения</span>
                <span>&middot;</span>
                <span>Технический разбор (без маркетинга)</span>
              </div>

         <!-- ===================================================== -->
            <div class="post-content">

                <h1 class="hero-title">ERP, которая не превращается в дорогой тормоз</h1>
                <p class="post-subtitle">
                  Почему ERP-системы ломаются одинаково: архитектурные ограничения 1С, SAP, Microsoft Dynamics, Odoo и других ERP-платформ и их поведение при изменении бизнес-правил.
                </p>

                <div class="callout" role="note">
                  <strong>Источник тезисов и метод</strong>
                  <p>
                    По мотивам технических статей на Хабре:
                    <a href="https://habr.com/ru/companies/lsfusion/articles/544982/" target="_blank" rel="noopener noreferrer">
                      «Почему lsFusion, а не 1С?»
                    </a>
                    и
                    <a href="https://habr.com/ru/companies/lsfusion/articles/468415/" target="_blank" rel="noopener noreferrer">
                      «Почему не 1С?»
                    </a>.
                    Дальше — инженерная «расшифровка»: механизмы, симптомы, диагностика на пилоте и способы снижения риска.
                  </p>
                </div>
              </header>

              <!-- ===================================================== -->
              <nav class="post-toc" id="toc">
                <h2>Содержание</h2>
                <ol>
                  <li>
                    <a href="#intro">Введение</a>
                    <ol>
                      <li><a href="#intro-why">Почему архитектурные ограничения ERP проявляются одинаково</a></li>
                      <li><a href="#intro-what-change">Что считать «изменением правил», а не доработкой</a></li>
                      <li><a href="#intro-how-to-read">Как читать этот разбор и что он даёт на практике</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#data-model">Модель данных и вычислений</a>
                    <ol>
                      <li><a href="#limit-2-1">Объекты: справочники, документы и т.д.</a></li>
                      <li><a href="#limit-2-2">Неэффективное получение данных объектов</a></li>
                      <li><a href="#limit-2-3">Таблицы и представления: регистры</a></li>
                      <li><a href="#limit-2-4">Регистры поддерживаются в очень частных случаях</a></li>
                      <li><a href="#limit-2-5">Отсутствие ограничений и событий для значений регистров</a></li>
                      <li><a href="#limit-2-6">В параметрах виртуальных таблиц можно использовать только константы</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#query-layer">Запросный слой и работа с данными</a>
                    <ol>
                      <li><a href="#limit-3-1">Запросы как самостоятельный слой системы</a></li>
                      <li><a href="#limit-3-2">Запросы в строках</a></li>
                      <li><a href="#limit-3-3">Отсутствие оптимизатора запросов</a></li>
                      <li><a href="#limit-3-4">Отсутствие расширенных SQL-возможностей</a></li>
                      <li><a href="#limit-3-5">Отсутствие запросов на изменение</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#execution-flow">Поток выполнения и консистентность данных</a>
                    <ol>
                      <li><a href="#limit-4-1">Отказ от автоматических блокировок</a></li>
                      <li><a href="#limit-4-2">Отказ от единого потока выполнения (сервер / клиент)</a></li>
                      <li><a href="#limit-4-3">Отказ от синхронности</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#forms-layer">Формы и представление данных</a>
                    <ol>
                      <li><a href="#limit-5-1">Формы как отдельный слой логики</a></li>
                      <li><a href="#limit-5-2">Отказ от WYSIWYG: разделение интерфейса на чтение и запись</a></li>
                      <li><a href="#limit-5-3">Ограничения контекста списков и форм</a></li>
                      <li><a href="#limit-5-4">Избыточные уровни абстракции в UI</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#language-architecture">Архитектура языка и расширяемость</a>
                    <ol>
                      <li><a href="#limit-6-1">Отсутствие наследования и полиморфизма</a></li>
                      <li><a href="#limit-6-2">Отсутствие явной типизации</a></li>
                      <li><a href="#limit-6-3">Отсутствие модульности</a></li>
                      <li><a href="#limit-6-4">Ставка на визуальное программирование</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#physical-model">Физическая модель и открытость системы</a>
                    <ol>
                      <li><a href="#limit-7-1">Закрытая физическая модель данных</a></li>
                      <li><a href="#limit-7-2">Статичная физическая модель данных</a></li>
                      <li><a href="#limit-7-3">Закрытые исходники и лицензии</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#operational-constraints">Эксплуатационные и культурные ограничения</a>
                    <ol>
                      <li><a href="#limit-8-1">Лицензирование и брендирование</a></li>
                      <li><a href="#limit-8-2">Фатальный недостаток как сумма решений</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#demo-pilot-check">Как проверять на демо и пилоте</a>
                    <ol>
                      <li><a href="#demo-what-to-ask">Три изменения для проверки</a></li>
                      <li><a href="#demo-what-to-watch">На что смотреть во время демонстрации</a></li>
                      <li><a href="#demo-red-flags">Типовые красные флаги</a></li>
                      <li><a href="#demo-result">Что считать хорошим результатом пилота</a></li>
                    </ol>
                  </li>

                  <li>
                    <a href="#conclusion">Заключение</a>
                  </li>
                </ol>
              </nav>


              <!-- ===================================================== -->
              <section class="post-content" id="intro">

                <h2 id="intro-why">1.1 Почему архитектурные ограничения ERP проявляются одинаково</h2>
                <p>
                  Большинство ERP (1С, SAP, Microsoft Dynamics, Odoo) на старте выглядят устойчиво: данных мало, процессы упрощены,
                  исключения редки, интеграции «тонкие». Архитектурные ограничения в этот момент почти не видны.
                </p>
                <p>
                  Проблемы проявляются позже — когда компания начинает менять правила. Причина не в «плохой системе»,
                  а в том, что типовые ERP построены вокруг схожих компромиссов: объектная модель, отдельный слой отчётности,
                  разнесённая логика (форма/сервер/интеграции), а также ограничения запросного слоя и массовых операций.
                  При росте данных и числа исключений эти компромиссы дают одинаковые симптомы независимо от вендора.
                </p>

                <div class="callout" role="note">
                  <strong>Важно</strong>
                  <p>
                    Этот материал не отвечает на вопрос «какая ERP лучше». Он отвечает на другой вопрос:
                    <strong>где и почему дорожает изменение правил</strong>, и как это распознать до промышленного запуска.
                  </p>
                </div>

                <hr>

                <h2 id="intro-what-change">1.2 Что считать «изменением правил», а не доработкой</h2>
                <p>
                  «Изменение правил» — это не «добавить поле» и не «сделать новый отчёт». Это изменение, которое одновременно:
                </p>
                <ul>
                  <li><strong>меняет поведение транзакций</strong> (валидность, проведение, статусы, ограничения);</li>
                  <li><strong>меняет показатели</strong> (маржа, себестоимость, лимиты, остатки, риск);</li>
                  <li><strong>меняет контроль</strong> (блокировки, согласования, запреты по условиям);</li>
                  <li><strong>не должно ломать</strong> отчётность и интеграции (CRM/WMS/маркетплейсы/BI).</li>
                </ul>
                <p>
                  Если платформа не держит это как единую модель (данные + расчёты + контроль), правило неизбежно реализуется
                  в нескольких местах. Тогда стоимость изменения определяется не сложностью формулы, а количеством слоёв,
                  которые нужно синхронно менять и проверять.
                </p>

                <hr>

                <h2 id="intro-how-to-read">1.3 Как читать этот разбор и что он даёт на практике</h2>
                <p>
                  Дальше идут конкретные архитектурные пункты (объекты, регистры, запросы, формы, блокировки, типизация и т.д.).
                  Для каждого пункта используется один и тот же формат:
                </p>
                <ul>
                  <li><strong>Что имеется в виду</strong> — ограничение без общих слов;</li>
                  <li><strong>Как это проявляется</strong> в 1С / SAP / Dynamics / Odoo (типовые механизмы, а не «в целом сложно»);</li>
                  <li><strong>Какой симптом вы увидите</strong> в эксплуатации (что реально «болит»);</li>
                  <li><strong>Как проверить на демо/пилоте</strong> — вопрос или сценарий, который вскрывает проблему.</li>
                </ul>

                <div class="callout" role="note">
                  <strong>Практический результат</strong>
                  <p>
                    После этого разбора вы сможете быстро отличать:
                    «правка правила» (предсказуемая работа в одном месте)
                    от «правки системы» (мульти-слойные изменения с дорогим регрессом),
                    и заранее понимать, где возникает зависимость от вендора или отдельных специалистов.
                  </p>
                </div>

              </section>

              <div class="callout" role="note">
  <strong>Чек-лист: как быстро понять, станет ли ERP «дорогим тормозом»</strong>
  <ul>
    <li>
      <strong>Одно правило — одно место?</strong><br>
      Попросите показать, где живёт конкретное правило (например, лимит/маржа/остаток) и сколько слоёв оно затрагивает.
      Если это код + форма + отчёт + обработка — изменения будут дорогими.
    </li>
    <li>
      <strong>Есть ли «момент завершения» операции?</strong><br>
      Спросите, когда операция считается окончательно выполненной (commit point) и что происходит асинхронно после «успеха».
      Если ответ расплывчатый — ждите «отложенных ошибок» и ручных проверок.
    </li>
    <li>
      <strong>Проверка на исключения</strong><br>
      Добавьте 2–3 исключения к типовой логике. Если сразу появляются «частные обработки» — модель не держит вариативность.
    </li>
    <li>
      <strong>Регресс контролируем?</strong><br>
      Спросите, как проверяют, что изменение правила не сломало отчёты/интеграции. Если «посмотрим глазами» — будет боль.
    </li>
    <li>
      <strong>Можно ли прогнозировать стоимость следующего изменения?</strong><br>
      Хорошая архитектура позволяет заранее сказать: “изменение затронет N механизмов и проверяется такими-то тестами”.
      Плохая — превращает каждую правку в исследование.
    </li>
  </ul>
</div>



              <hr>

              <!-- ===================================================== -->
              <section class="post-content" id="data-model">

                <h2 id="data-model-title">2. Модель данных и вычислений</h2>
                <p>
                  Этот раздел — про фундамент: <strong>как в ERP устроены данные и вычисления</strong>
                  и какие ограничения закладываются ещё до кода, форм и интеграций.
                  Именно здесь определяется, можно ли выразить бизнес-правила как единую модель
                  или они неизбежно будут расползаться по системе.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-2-1">2.1 Объекты: справочники, документы и т.д.</h3>

                <p><strong>Как это обычно реализовано в ERP</strong></p>
                <p>
                  Большинство ERP строятся вокруг объектной модели:
                  справочники, документы, строки, движения.
                  Бизнес-логика привязывается к жизненному циклу объекта
                  (создание, редактирование, проведение),
                  а не описывается как отдельная система правил.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Метаданные (Справочники, Документы, Регистры) — основа архитектуры.
                  Проверки и расчёты распределяются между проведением,
                  модулями форм и служебными обработчиками.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Объектная модель дополняется настройками и расширениями,
                  но правило часто оказывается композицией стандартного объекта,
                  кастомного кода и процессного слоя.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Entities служат точкой входа,
                  но логика распределяется между плагинами,
                  автоматизациями и клиентскими правилами.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  ORM-модели выглядят целостно,
                  но при росте кастомизации логика распределяется
                  между моделями, computed fields и модулями.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  одно бизнес-правило реализовано в нескольких объектах и слоях;
                  объяснение «почему система так посчитала» требует знания истории внедрения.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить показать одно правило
                  и все объекты, где оно реализовано или влияет на поведение.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-2-2">2.2 Неэффективное получение данных объектов</h3>

                <p><strong>Как это обычно реализовано в ERP</strong></p>
                <p>
                  Объекты удобны для транзакций,
                  но плохо подходят для сложных вычислений.
                  В итоге данные извлекаются частично запросами,
                  частично через объекты,
                  а расчёт собирается процедурно.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Типовой сценарий: запрос + чтение объектов + циклы.
                  Производительность зависит от дисциплины разработчика.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Данные доступны через несколько уровней модели,
                  что усложняет контроль фактических выборок.
                </p>

                <p><strong>Dynamics</strong></p>
                <p>
                  ORM/API легко порождают множество обращений
                  вместо одной оптимальной выборки.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  ORM скрывает реальные запросы;
                  проблемы проявляются при росте данных.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  система деградирует по производительности
                  не сразу, а «вдруг» — при росте объёма.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-2-3">2.3 Таблицы и представления: регистры</h3>

                <p><strong>Как это обычно реализовано в ERP</strong></p>
                <p>
                  Для аналитики вводится отдельный слой:
                  агрегаты, движения, представления.
                  Возникает второй источник истины,
                  отличающийся от транзакционных данных.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Регистры — ключевой механизм,
                  но логика расчёта часто частично остаётся в коде.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Аналог — сочетание движений,
                  агрегатов и аналитических представлений.
                </p>

                <p><strong>Dynamics</strong></p>
                <p>
                  Агрегаты часто выносятся в BI или витрины.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Типовые агрегаты есть,
                  но при росте требований появляются SQL views и внешняя аналитика.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  операции и отчёты расходятся,
                  пересчёты требуют специальных процедур.
                </p>

                <hr>

                <!-- ===================================================== -->
               <h3 id="limit-2-4">2.4 Регистры поддерживаются в очень частных случаях</h3>

                  <p><strong>Что имеется в виду</strong></p>
                  <p>
                    Аналитический слой (регистры/агрегаты/витрины) хорошо работает, пока бизнес-правило укладывается
                    в «типовой» паттерн: остатки, обороты, простые разрезы, стандартные периоды.
                    Как только появляется нетиповая семантика (исключения, условные правила, альтернативные источники,
                    исторические «как было на дату» по нестандартному признаку), часть логики перестаёт выражаться
                    в модели и уходит в код/обработки/интеграции.
                  </p>

                  <p><strong>Как это проявляется в стандартных ERP</strong></p>

                  <p><strong>1С</strong></p>
                  <p>
                    Регистры (накопления/бухгалтерии/сведений) покрывают множество сценариев,
                    но реальная логика часто распадается: часть — в движениях при проведении,
                    часть — в запросах отчётов (СКД), часть — в обработках пересчёта.
                    Как только нужен «нештатный» алгоритм (условные перерасчёты, сложные исключения, альтернативная оценка),
                    он уходит в процедурный код и перестаёт быть частью единой модели.
                  </p>

                  <p><strong>SAP</strong></p>
                  <p>
                    Типовые учёты и аналитика держатся на богатой модели и механизмах расширения,
                    но «нестандарт» часто реализуется смесью настроек + расширений + отдельной аналитической модели
                    (или выносом в отдельный слой аналитики). В итоге правило существует сразу в нескольких местах,
                    а синхронизация становится проектом.
                  </p>

                  <p><strong>Microsoft Dynamics</strong></p>
                  <p>
                    В типовом контуре показатели часто «разводятся» по слоям: транзакционные сущности,
                    правила/плагины, отчётные представления и внешняя аналитика. Нестандартные правила
                    почти неизбежно оказываются в комбинации: код + low-code автоматизации + витрина/BI.
                  </p>

                  <p><strong>Odoo</strong></p>
                  <p>
                    Базовые агрегаты и computed-поля работают до определённой сложности.
                    Дальше появляются: отдельные модели для «производных» показателей, SQL views,
                    фоновые пересчёты и внешняя аналитика. Правило перестаёт быть «частью модели»
                    и превращается в набор реализаций.
                  </p>

                  <p>
                    <strong>Эксплуатационный симптом:</strong>
                    часть правил живёт в «модели» (регистры/агрегаты), часть — в «особых обработках».
                    Малое изменение начинает требовать правок в нескольких местах, а объяснимость
                    «почему так посчиталось» падает.
                  </p>

                  <p>
                    <strong>Как проверить на демо/пилоте:</strong>
                    попросить взять один показатель (например, доступный остаток/маржа/лимит) и добавить
                    2–3 исключения (по типу клиента, складу, дате, альтернативному источнику цены).
                    Смотри, сохраняется ли <em>единый механизм</em> (одно место/один тип механизма) или правило «расползается»
                    на код + отчёт + пересчёт + интеграцию.
                  </p>

                  <h3 id="limit-2-5">2.5 Отсутствие ограничений и событий для значений регистров</h3>
                                    <hr>

                    <p><strong>Что имеется в виду</strong></p>
                    <p>
                      Во многих ERP ограничения и события хорошо определены для операций (документ/проведение/запись),
                      но плохо определены для <strong>вычисленных/агрегированных значений</strong> (остатки, лимиты, рейтинги, риск).
                      То есть платформа не даёт нативного механизма уровня:
                      «если агрегат стал таким — запрети/оповести/запусти реакцию», как часть модели.
                      Поэтому контроль реализуют процедурно: проверками при проведении, фоновыми проверками,
                      отчётами-валидаторами и ручными регламентами.
                    </p>

                    <p><strong>Как это проявляется в стандартных ERP</strong></p>

                    <p><strong>1С</strong></p>
                    <p>
                      Типовой путь — проверять «по месту» при проведении документа или в форме.
                      Но агрегат (например, лимит/остаток/оборачиваемость) может меняться не только из одного документа:
                      из нескольких видов операций, ретро-изменений, пересчётов, обменов. Тогда контроль начинает дублироваться,
                      а «когда именно сработает запрет» зависит от сценария.
                    </p>

                    <p><strong>SAP</strong></p>
                    <p>
                      Контроль часто строят через статусы/процессы/проверки в транзакциях,
                      а мониторинг агрегатов — отдельными механизмами (процедуры контроля, отчёты, workflow).
                      Формально это мощно, но правило чаще становится процессной конструкцией,
                      а не декларативным ограничением на значение.
                    </p>

                    <p><strong>Microsoft Dynamics</strong></p>
                    <p>
                      Бизнес-правила и плагины удобно вешать на событие изменения сущности,
                      но агрегаты обычно считаются отдельно (фон, интеграция, отчётный слой).
                      В итоге «ограничение на агрегат» реализуется как набор проверок + автоматизаций,
                      и его трудно доказуемо сделать полным (без дыр).
                    </p>

                    <p><strong>Odoo</strong></p>
                    <p>
                      Есть constraints и onchange на уровне моделей, но агрегаты часто живут в computed fields,
                      которые могут пересчитываться лениво/по триггерам/по крону. Поэтому контроль по агрегату
                      легко становится недетерминированным: «иногда ловит, иногда нет», если не выстроить строгую дисциплину.
                    </p>

                    <p>
                      <strong>Эксплуатационный симптом:</strong>
                      запреты и контроль работают «не всегда одинаково»:
                      один пользователь ловит ограничение сразу, другой — позже;
                      часть нарушений обнаруживается отчётом/проверкой после факта.
                      Появляются регламенты «проверяйте вручную».
                    </p>

                    <p>
                      <strong>Как проверить на демо/пилоте:</strong>
                      попросить сделать ограничение на агрегат:
                      «нельзя отгружать, если суммарный риск/лимит по клиенту &gt; X, с учётом всех документов и корректировок».
                      Затем попросить показать 3 пути изменения агрегата (документ, корректировка задним числом, интеграция/импорт)
                      и убедиться, что ограничение срабатывает одинаково во всех трёх сценариях.
                    </p>

                    <hr>

                    <h3 id="limit-2-6">2.6 В параметрах виртуальных таблиц можно использовать только константы</h3>

                      <p><strong>Что имеется в виду</strong></p>
                      <p>
                        Когда аналитический слой можно параметризовать только константами (или очень ограниченно),
                        система не умеет «подстраивать» вычисление под контекст операции.
                        В итоге приходится:
                        (1) выбирать данные «шире, чем нужно», а затем фильтровать в коде/форме,
                        (2) создавать копии запросов/отчётов под разные варианты,
                        (3) выносить часть логики из модели в процедурные слои.
                        Это тихо увеличивает стоимость изменений: любое новое условие порождает новые копии.
                      </p>

                      <p><strong>Как это проявляется в стандартных ERP</strong></p>

                      <p><strong>1С</strong></p>
                      <p>
                        Типовой эффект: отчёт/запрос «универсальный» только на словах.
                        Как только появляются условия «зависящие от контекста» (текущий пользователь, роль, состояние документа,
                        параметры формы), часть фильтрации уходит в код, а запросы копируются.
                        Со временем возникает «зоопарк» вариантов почти одинаковых отчётов/выборок.
                      </p>

                      <p><strong>SAP</strong></p>
                      <p>
                        Контекстные условия часто решаются настройками, параметрами представлений и процессными слоями,
                        но при росте вариативности появляется тот же паттерн: разные варианты представлений/запросов/ролей
                        вместо одного описанного правила. Цена — сложность сопровождения и риск расхождения логики.
                      </p>

                      <p><strong>Microsoft Dynamics</strong></p>
                      <p>
                        Ограничения выражений и контекста приводят к размножению представлений/запросов/flows:
                        «для этой роли одно», «для этой формы другое». Когда бизнес меняет правило,
                        приходится искать все копии и синхронно править.
                      </p>

                      <p><strong>Odoo</strong></p>
                      <p>
                        ORM удобен, но сложный контекст часто приводит к:
                        доменам/контекстам на уровне UI + отдельным методам выборки в коде + SQL для тяжёлых случаев.
                        Вариативность фильтров быстро порождает дубли и «локальные решения».
                      </p>

                      <p>
                        <strong>Эксплуатационный симптом:</strong>
                        появляются «почти одинаковые» отчёты, списки и выборки.
                        Малое изменение условия (ещё один фильтр/исключение) превращается в серию правок:
                        запрос, код формы, права, отдельный отчёт, отдельная обработка.
                      </p>

                      <p>
                        <strong>Как проверить на демо/пилоте:</strong>
                        попросить реализовать один и тот же список/отчёт с 3 контекстами:
                        (1) для бухгалтера, (2) для менеджера, (3) для руководителя — с разными фильтрами и колонками,
                        но с одним источником правила. Затем попросить изменить правило (добавить исключение)
                        и посмотреть, меняют ли это в одном месте или в нескольких копиях.
                      </p>




              <!-- ===================================================== -->
              <section class="post-content" id="query-layer">

                <h2 id="query-layer-title">3. Запросный слой и работа с данными</h2>
                <p>
                  Этот раздел — про то, <strong>насколько запросы являются управляемой частью архитектуры ERP</strong>.
                  Здесь становится видно, можно ли выражать бизнес-логику декларативно
                  и предсказуемо менять её стоимость,
                  или же любые изменения превращаются в риск по производительности и регрессу.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-3-1">3.1 Запросы как самостоятельный слой системы</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  В большинстве ERP запросы предназначены для чтения данных и отчётности.
                  Бизнес-правила (валидации, расчёты, ограничения)
                  реализуются в прикладной логике:
                  в коде объектов, обработчиках, workflow и автоматизациях.
                  Запросный слой не считается источником истины для правил.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Запросы активно используются в отчётах и аналитике (СКД),
                  но проведение документов и контроль выполняются в коде.
                  Один и тот же показатель часто считается:
                  один раз в запросе, второй — в обработчике.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Расчёты распределяются между CDS View, ABAP-кодом и настройками.
                  Эти уровни мощные, но не образуют единого языка правил.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Views и FetchXML — для чтения,
                  бизнес-правила — в плагинах, flows и клиентских скриптах.
                  Запрос не является носителем логики.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  ORM-запросы используются для выборок,
                  а логика реализуется в Python-коде и computed fields.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  невозможно однозначно ответить,
                  где именно считается показатель и какая версия формулы «главная».
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить показать все места,
                  где используется один и тот же расчёт,
                  и как обеспечивается их идентичность.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-3-2">3.2 Запросы в строках</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Запросы и условия часто задаются в виде строк:
                  текст SQL, выражения фильтров, формулы в настройках.
                  Платформа не может анализировать их структуру
                  и проверять влияние изменений.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Запросы — строковые.
                  Ошибки и зависимости выявляются только в рантайме.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  В стандартных слоях контроль выше,
                  но кастом и интеграции быстро приводят к текстовым конструкциям.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Условия и выражения в flows и настройках
                  формально no-code, но по сути строковые.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Raw SQL решает задачи,
                  но ломает анализ зависимостей и обновления.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  изменение схемы данных приводит к ошибкам «постфактум»,
                  появляется правило «лучше не трогать».
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-3-3">3.3 Отсутствие предсказуемой оптимизации как части модели правил</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Производительность запросов не выводится из модели правил.
                  Она достигается за счёт ручной оптимизации,
                  индексов и опыта разработчиков.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Запрос может быть логически корректным,
                  но физически неэффективным.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Сильная СУБД помогает,
                  но сложные модели дают неожиданные планы выполнения.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Сложную аналитику часто выносят в BI,
                  а не оптимизируют внутри ERP.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  ORM скрывает реальные планы выполнения,
                  оптимизация становится «искусством».
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  отчёты «летят» на тесте и деградируют на реальных данных.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-3-4">3.4 Отсутствие расширенных SQL-возможностей</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Поддержка оконных функций, CTE и условных агрегатов
                  либо ограничена, либо требует обходов.
                  В итоге расчёты распадаются на несколько шагов и код.
                </p>

                <p><strong>Эксплуатационный симптом:</strong>
                  одинаковые формулы дублируются,
                  сложно понять, где именно считается показатель.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить показать сложный управленческий расчёт
                  без циклов и временных таблиц.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-3-5">3.5 Отсутствие запросов на изменение (UPDATE / DELETE / MERGE)</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Массовые изменения данных
                  не считаются штатной частью языка запросов.
                  Используются циклы, обработки или внешние инструменты.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Массовые изменения = перебор объектов и перепроведение.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Массовые операции возможны,
                  но требуют высокой квалификации и осторожности.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Массовые изменения часто выносятся в ETL и Dataflows.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  ORM медленный для массовых операций,
                  raw SQL рискован по поддержке.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  пересчёты выполняются ночью,
                  считаются опасными и редкими.
                </p>

              </section>

              <!-- ===================================================== -->
              <section class="post-content" id="execution-flow">

              <h2 id="execution-flow-title">4. Поток выполнения и гарантии консистентности данных</h2>
              <p>
                Этот раздел — про гарантии, а не про удобство.
                Про то, <strong>можно ли формально определить момент завершения операции</strong>,
                источник истины и порядок применения бизнес-правил.
                Именно отсутствие формальных гарантий приводит к ошибкам,
                которые «невозможно воспроизвести» и подрывают доверие к данным.
              </p>

              <hr>

              <h3 id="limit-4-1">4.1 Отказ от автоматических блокировок</h3>

              <p><strong>Суть ограничения</strong></p>
              <p>
                Многие ERP жертвуют строгими блокировками ради отзывчивости интерфейса.
                В результате платформа не гарантирует атомарность бизнес-операции:
                несколько пользователей или процессов могут изменить связанные данные
                без единой точки синхронизации.
              </p>

              <p><strong>Гарантия, которой нет</strong></p>
              <p>
                Нет формального утверждения:
                «в момент X данные были согласованы и не могли измениться конкурентно».
              </p>

              <p>
                <strong>Эксплуатационный симптом:</strong>
                редкие, нерегулярные ошибки,
                которые невозможно стабильно воспроизвести;
                объяснение сводится к «одновременным действиям».
              </p>

              <p>
                <strong>Как проверить:</strong>
                попросить показать,
                что происходит при одновременном изменении
                одного и того же объекта несколькими пользователями
                и где именно фиксируется конфликт.
              </p>

              <hr>

              <h3 id="limit-4-2">4.2 Отказ от единого потока выполнения</h3>

              <p><strong>Суть ограничения</strong></p>
              <p>
                Бизнес-логика распределяется между клиентом,
                сервером, фоновыми процессами и интеграциями.
                В системе отсутствует единый детерминированный поток выполнения.
              </p>

              <p><strong>Гарантия, которой нет</strong></p>
              <p>
                Нельзя формально ответить:
                «какие проверки и расчёты были применены именно к этой операции».
              </p>

              <p>
                <strong>Эксплуатационный симптом:</strong>
                пользователь видит одно поведение,
                а итоговое состояние данных отличается;
                возникают «непонятные» отказы и откаты.
              </p>

              <p>
                <strong>Как проверить:</strong>
                попросить показать,
                какие проверки выполняются гарантированно на сервере,
                какие — только в UI,
                и что произойдёт при обходе интерфейса.
              </p>

              <hr>

              <h3 id="limit-4-3">4.3 Отказ от синхронности и чёткого commit point</h3>

              <p><strong>Суть ограничения</strong></p>
              <p>
                Ради скорости операции выполняются асинхронно:
                расчёты, интеграции, пересчёты показателей.
                Пользователь получает подтверждение,
                но бизнес-операция ещё не завершена логически.
              </p>

              <p><strong>Гарантия, которой нет</strong></p>
              <p>
                Отсутствует чёткий commit point —
                момент, после которого можно утверждать,
                что операция завершена и её эффект окончателен.
              </p>

              <p>
                <strong>Эксплуатационный симптом:</strong>
                дубли операций,
                «отложенные ошибки»,
                ручные проверки и повторные действия пользователей.
              </p>

              <p>
                <strong>Как проверить:</strong>
                спросить,
                в какой момент операция считается завершённой,
                какие действия выполняются после подтверждения
                и возможны ли откаты задним числом.
              </p>

            </section>


              <!-- ===================================================== -->
              <section class="post-content" id="forms-layer">

                <h2 id="forms-layer-title">5. Формы и представление данных</h2>
                <p>
                  Этот раздел — про то, как пользователь взаимодействует с моделью данных
                  и какие архитектурные последствия возникают,
                  когда интерфейс перестаёт быть прямым отражением бизнес-логики.
                  Здесь ошибки выглядят как «человеческий фактор»,
                  но их причина — в устройстве системы.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-5-1">5.1 Формы как отдельный слой логики</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Формы в ERP редко являются просто отображением данных.
                  В них добавляется логика:
                  проверки, вычисления, скрытие полей,
                  автозаполнение, реакции на события.
                  Со временем форма становится ещё одним местом,
                  где живут бизнес-правила.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Значительная часть логики реализуется в модулях форм:
                  проверки при изменении полей,
                  пересчёты, управление доступностью.
                  Эта логика не всегда дублируется на сервере.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  UI-логика распределяется между экранными сценариями,
                  backend-проверками и процессными правилами.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Клиентские скрипты и бизнес-правила в интерфейсе
                  дополняют серверные плагины,
                  создавая несколько уровней поведения.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Формы относительно просты,
                  но при кастомизации логика начинает дублировать backend.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  поведение зависит от того,
                  как именно пользователь вводит данные,
                  через какую форму или сценарий.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить показать,
                  какие проверки выполняются только в форме
                  и что произойдёт при загрузке данных в обход UI.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-5-2">5.2 Отказ от WYSIWYG: разделение интерфейса на запись и чтение</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Режимы просмотра и редактирования
                  реализуются по-разному:
                  разные события, разные проверки,
                  разные вычисления.
                  Пользователь видит одно,
                  а система сохраняет другое.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Разные режимы формы и события
                  приводят к расхождениям
                  между отображением и сохранением.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Многошаговые экраны и статусы
                  усложняют понимание,
                  что именно зафиксировано.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Часть полей вычисляется или обновляется асинхронно,
                  что создаёт эффект «визуальной фиксации».
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Базово WYSIWYG соблюдён,
                  но при усложнении форм появляются расхождения.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  пользователь уверен, что данные сохранены,
                  но система позже их меняет или откатывает.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить показать,
                  совпадает ли значение поля на экране
                  с тем, что реально записано в базе
                  в момент сохранения.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-5-3">5.3 Невозможность обращаться в списках к реквизитам форм и текущим значениям других списков</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Списки и формы живут в разных контекстах.
                  Логика списка ограничена доступными полями данных,
                  а текущие значения формы или других списков
                  недоступны напрямую.
                </p>

                <p><strong>Следствие</strong></p>
                <p>
                  Контекстные правила (зависящие от текущего выбора,
                  состояния формы, связанных списков)
                  реализуются обходными путями или дублируются.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  интерфейс не может корректно отразить
                  реальные ограничения и правила,
                  появляются «непонятные» запреты.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить реализовать правило,
                  зависящее от состояния нескольких списков,
                  без дополнительного кода и обходов.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-5-4">5.4 Избыточные уровни абстракции в UI</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Для универсальности и расширяемости
                  интерфейс строится через несколько уровней:
                  метаданные → формы → конфигурации → сценарии.
                  Каждый уровень добавляет гибкость,
                  но снижает прозрачность.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  простое изменение поведения формы
                  требует понимания нескольких уровней абстракции
                  и затрагивает больше мест, чем ожидается.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить показать,
                  через какие слои проходит изменение
                  одного UI-правила
                  и где именно оно зафиксировано.
                </p>

              </section>

                <!-- ===================================================== -->
                <section class="post-content" id="language-architecture">

                  <h2 id="language-architecture-title">6. Архитектура языка и расширяемость</h2>
                  <p>
                    Этот раздел — про то, <strong>насколько ERP вообще является инженерной платформой</strong>,
                    а не набором инструментов для конфигурации.
                    Здесь определяется, можно ли развивать систему как кодовую базу
                    с предсказуемыми изменениями,
                    или она неизбежно превращается в артефакт внедрения,
                    зависящий от конкретных людей и договорённостей.
                  </p>

                  <hr>

                  <!-- ===================================================== -->
                  <h3 id="limit-6-1">6.1 Отсутствие наследования и полиморфизма</h3>

                  <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                  <p>
                    ERP почти всегда работает с семействами сущностей:
                    договоры, заказы, услуги, проекты.
                    Однако во многих платформах
                    нет полноценной модели наследования бизнес-сущностей.
                    В результате схожая логика копируется,
                    а различия реализуются через условия.
                  </p>

                  <p><strong>1С</strong></p>
                  <p>
                    Наследование ограничено.
                    Типовой подход — копирование объектов
                    с последующими доработками.
                  </p>

                  <p><strong>SAP</strong></p>
                  <p>
                    Возможности шире,
                    но сложность модели приводит к тому,
                    что логика базовых и производных сущностей
                    расходится по расширениям.
                  </p>

                  <p><strong>Microsoft Dynamics</strong></p>
                  <p>
                    Расширение сущностей возможно,
                    но полиморфизм чаще имитируется
                    через плагины и условия.
                  </p>

                  <p><strong>Odoo</strong></p>
                  <p>
                    Наследование — сильная сторона,
                    но при активных override'ах
                    важно контролировать точки изменения поведения.
                  </p>

                  <p>
                    <strong>Эксплуатационный симптом:</strong>
                    правила дублируются,
                    изменения в «базовой логике»
                    требуют ручной синхронизации.
                  </p>

                  <hr>

                  <!-- ===================================================== -->
                  <h3 id="limit-6-2">6.2 Отсутствие явной типизации в коде</h3>

                  <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                  <p>
                    Явная типизация часто отсутствует
                    или ослаблена ради гибкости.
                    Ошибки выявляются в рантайме,
                    а анализ логики возможен
                    только опытным путём.
                  </p>

                  <p><strong>1С</strong></p>
                  <p>
                    Слабая типизация затрудняет анализ
                    больших конфигураций
                    и безопасный рефакторинг.
                  </p>

                  <p><strong>SAP</strong></p>
                  <p>
                    Типизация сильнее,
                    но цена — высокая сложность
                    и требования к квалификации команды.
                  </p>

                  <p><strong>Microsoft Dynamics</strong></p>
                  <p>
                    Типы есть,
                    но при смешении low-code и плагинов
                    контракт поведения размывается.
                  </p>

                  <p><strong>Odoo</strong></p>
                  <p>
                    Динамический Python
                    требует строгих соглашений,
                    иначе ошибки проявляются поздно.
                  </p>

                  <p>
                    <strong>Эксплуатационный симптом:</strong>
                    изменения проверяются «на глаз»,
                    растёт число регрессионных ошибок.
                  </p>

                  <hr>

                  <!-- ===================================================== -->
                  <h3 id="limit-6-3">6.3 Отсутствие модульности</h3>

                  <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                  <p>
                    Формальное разделение на модули
                    не гарантирует архитектурной изоляции.
                    Зависимости становятся неявными,
                    а изменение одного блока
                    затрагивает смежные.
                  </p>

                  <p><strong>1С</strong></p>
                  <p>
                    Общие модули разрастаются,
                    границы ответственности размываются.
                  </p>

                  <p><strong>SAP</strong></p>
                  <p>
                    Модульность есть на уровне процессов,
                    но настройки и расширения
                    размывают границы.
                  </p>

                  <p><strong>Microsoft Dynamics</strong></p>
                  <p>
                    Композиционность работает
                    до определённого масштаба,
                    затем локальность изменений теряется.
                  </p>

                  <p><strong>Odoo</strong></p>
                  <p>
                    Модульность изначально сильная,
                    но слабый контроль зависимостей
                    превращает обновления в проект.
                  </p>

                  <p>
                    <strong>Эксплуатационный симптом:</strong>
                    «маленькие» изменения
                    перестают быть маленькими,
                    растёт объём регресса.
                  </p>

                  <hr>

                  <!-- ===================================================== -->
                  <h3 id="limit-6-4">6.4 Ставка на визуальное программирование</h3>

                  <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                  <p>
                    Low-code и визуальные схемы
                    ускоряют старт,
                    но плохо масштабируются
                    как носитель бизнес-логики.
                    Зависимости трудно анализировать,
                    правила сложно тестировать.
                  </p>

                  <p><strong>1С</strong></p>
                  <p>
                    Визуальные механизмы
                    смешиваются с кодом,
                    логика распыляется.
                  </p>

                  <p><strong>SAP</strong></p>
                  <p>
                    Workflow и настройки мощные,
                    но трассировка «почему сработало»
                    становится нетривиальной.
                  </p>

                  <p><strong>Microsoft Dynamics</strong></p>
                  <p>
                    Flows удобны,
                    но при росте превращаются
                    в трудноуправляемый набор сценариев.
                  </p>

                  <p><strong>Odoo</strong></p>
                  <p>
                    Визуальные инструменты менее агрессивны,
                    но перенос логики из кода в настройки
                    даёт те же эффекты.
                  </p>

                  <p>
                    <strong>Эксплуатационный симптом:</strong>
                    правила существуют как «схемы»,
                    а не как единая модель,
                    сопровождение зависит от конкретных людей.
                  </p>

                </section>

              <!-- ===================================================== -->
              <section class="post-content" id="physical-model">

                <h2 id="physical-model-title">7. Физическая модель и открытость системы</h2>
                <p>
                  Этот раздел — про то, <strong>насколько ERP прозрачна как инженерная система</strong>.
                  Даже при аккуратной логике, хороших формах и дисциплине разработки
                  закрытая или негибкая физическая модель данных
                  резко увеличивает стоимость изменений, диагностики и интеграций.
                </p>
                <p>
                  Здесь появляются ограничения, которые невозможно «обойти аккуратным кодом» —
                  они определяются самим устройством платформы.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-7-1">7.1 Закрытая физическая модель данных</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Во многих ERP физическая модель данных либо скрыта,
                  либо доступна только через абстракции платформы.
                  Разработчик работает с логической моделью,
                  не имея полного контроля над тем,
                  как данные реально хранятся и связаны.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Физическая структура БД формируется платформой.
                  Прямой анализ и оптимизация возможны,
                  но не считаются штатным способом работы.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Модель данных формально открыта,
                  но чрезвычайно сложна.
                  Без глубокой экспертизы вмешательство рискованно.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  В SaaS-модели физическая БД скрыта.
                  Работа ведётся через Dataverse, API и витрины.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Физическая модель доступна,
                  но модули и кастомизация
                  быстро усложняют реальную картину.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  диагностика проблем и анализ последствий изменений
                  требуют специальных знаний или доступа,
                  который есть не у команды, а у вендора или интегратора.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  спросить,
                  можно ли без обходных путей
                  проанализировать реальные таблицы,
                  индексы и связи для конкретного расчёта.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-7-2">7.2 Статичная физическая модель данных</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Физическая модель оптимизирована под типовые сценарии.
                  Изменение структуры данных
                  либо невозможно,
                  либо требует сложных миграций и согласований.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Изменения структуры возможны,
                  но на больших объёмах данных
                  превращаются в отдельные проекты.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Изменения допустимы,
                  но затрагивают множество зависимых объектов
                  и требуют строгой процедуры.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  Расширение схемы возможно,
                  но в рамках ограничений SaaS-платформы.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Модель можно менять,
                  но это влияет на обновляемость и совместимость модулей.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  изменение модели данных откладывается,
                  накапливаются «временные» решения и дополнительные таблицы.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  попросить показать,
                  как добавляется новое измерение или сущность
                  с учётом исторических данных.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-7-3">7.3 Закрытые исходники и лицензии</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Исходный код и внутренние механизмы
                  частично или полностью закрыты.
                  Возможности анализа и изменения
                  ограничены условиями лицензии.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Платформа закрыта,
                  поведение многих механизмов нельзя изучить напрямую.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Код доступен ограниченно,
                  изменения требуют соблюдения строгих правил.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  SaaS-модель усиливает зависимость от вендора
                  и ограничивает низкоуровневый контроль.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Open-source ядро снижает барьер,
                  но коммерческие модули и экосистема
                  могут создавать новый lock-in.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  команда не может самостоятельно разобраться
                  в причинах поведения системы
                  и вынуждена полагаться на поддержку или партнёров.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  спросить,
                  какие части системы можно анализировать,
                  отлаживать и менять без участия вендора.
                </p>

              </section>

              <!-- ===================================================== -->
              <section class="post-content" id="operational-constraints">

                <h2 id="operational-constraints-title">8. Эксплуатационные и культурные ограничения</h2>
                <p>
                  Этот раздел — про ограничения, которые формально не относятся к архитектуре,
                  но на практике <strong>определяют, какой архитектурой система может быть</strong>.
                  Лицензирование, правила использования и позиция вендора
                  напрямую влияют на тестирование, автоматизацию,
                  скорость изменений и зависимость от внешних участников.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-8-1">8.1 Неуважительные по отношению к разработчикам лицензирование и брендирование</h3>

                <p><strong>Как это обычно реализовано в стандартных ERP</strong></p>
                <p>
                  Лицензирование часто строится вокруг пользователей,
                  окружений и отдельных компонентов.
                  Это ограничивает количество тестовых стендов,
                  усложняет CI/CD и делает эксперименты дорогими.
                  Брендирование и жёсткие правила использования
                  подчёркивают зависимость от вендора.
                </p>

                <p><strong>1С</strong></p>
                <p>
                  Лицензии на пользователей и серверы
                  ограничивают количество полноценных контуров.
                  Часто существует один «живой» стенд,
                  где и тестируют изменения.
                </p>

                <p><strong>SAP</strong></p>
                <p>
                  Стоимость лицензий и окружений
                  делает каждый дополнительный стенд предметом согласования.
                  Автоматизация тестирования ограничена.
                </p>

                <p><strong>Microsoft Dynamics</strong></p>
                <p>
                  SaaS-лицензирование ограничивает доступ
                  к низкоуровневым механизмам
                  и усложняет изоляцию экспериментов.
                </p>

                <p><strong>Odoo</strong></p>
                <p>
                  Open-source снижает барьер входа,
                  но коммерческие модули и сервисы
                  могут накладывать схожие ограничения.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  меньше тестовых контуров,
                  правки проверяются «на проде»,
                  изменения выкатываются реже и осторожнее,
                  чем требует бизнес.
                </p>

                <p>
                  <strong>Как проверить:</strong>
                  спросить,
                  сколько полноценных окружений
                  можно держать без дополнительных лицензий
                  и какие из них подходят для автоматических тестов.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="limit-8-2">8.2 Фатальный недостаток как сумма архитектурных решений</h3>

                <p>
                  Ни одно из описанных ограничений
                  не является фатальным само по себе.
                  Проблема возникает,
                  когда они накладываются друг на друга.
                </p>

                <ul>
                  <li>правила размазаны по объектам, формам и запросам;</li>
                  <li>запросный слой не является источником истины;</li>
                  <li>нет чётких гарантий потока выполнения;</li>
                  <li>модель данных закрыта или негибка;</li>
                  <li>эксперименты и тестирование дороги.</li>
                </ul>

                <p>
                  В такой системе любое изменение —
                  даже логически простое —
                  превращается в проект:
                  с анализом последствий,
                  ручным регрессом
                  и зависимостью от конкретных людей.
                </p>

                <p>
                  <strong>Эксплуатационный симптом:</strong>
                  команда избегает изменений,
                  бизнес перестаёт задавать вопросы «а можно ли иначе»,
                  ERP фиксирует текущий способ работы
                  вместо того, чтобы поддерживать развитие.
                </p>

              </section>

              <!-- ===================================================== -->
              <section class="post-content" id="demo-pilot-check">

                <h2 id="demo-pilot-check-title">9. Как проверять архитектурные ограничения на демо и пилоте</h2>
                <p>
                  Архитектурные ограничения почти никогда не видны
                  в презентациях и типовых сценариях.
                  На демо показывают «что система умеет»,
                  но не «сколько стоит изменение правил».
                </p>
                <p>
                  Единственный надёжный способ —
                  проверять ERP не по функциям,
                  а по <strong>реакции на изменения</strong>.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="demo-what-to-ask">9.1 Три изменения, которые стоит попросить показать</h3>

                <p>
                  Для проверки достаточно трёх сценариев.
                  Важно не то, что «получилось»,
                  а <strong>как именно это делалось</strong>.
                </p>

                <ol>
                  <li>
                    <strong>Изменение правила с исключениями</strong><br>
                    Например: скидка или лимит,
                    зависящие от нескольких условий
                    (тип клиента, оборот, риск, история).
                  </li>
                  <li>
                    <strong>Изменение процесса</strong><br>
                    Согласование не «по должности»,
                    а по данным:
                    сумма, маржа, риск, отклонение от нормы.
                  </li>
                  <li>
                    <strong>Добавление нового типа сущности</strong><br>
                    Новый договор, услуга или модель расчёта,
                    которая должна:
                    участвовать в транзакциях,
                    попадать в отчёты
                    и подчиняться тем же правилам контроля.
                  </li>
                </ol>

                <p>
                  Эти сценарии затрагивают:
                  модель данных,
                  расчёты,
                  формы,
                  запросы,
                  контроль и интеграции —
                  именно там и проявляются ограничения.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="demo-what-to-watch">9.2 На что смотреть во время демонстрации</h3>

                <ul>
                  <li>
                    <strong>Сколько слоёв пришлось менять</strong><br>
                    Один модуль или форма —
                    это изменение правила.
                    Несколько слоёв —
                    изменение системы.
                  </li>
                  <li>
                    <strong>Где именно описано правило</strong><br>
                    Можно ли показать одно место,
                    или логика распределена
                    между кодом, формами и запросами.
                  </li>
                  <li>
                    <strong>Как объясняется влияние на отчёты</strong><br>
                    Есть ли чёткий ответ,
                    какие показатели изменятся
                    и почему.
                  </li>
                  <li>
                    <strong>Есть ли проверка регресса</strong><br>
                    Тест, сценарий или хотя бы формальный чек-лист,
                    а не «после посмотрим».
                  </li>
                </ul>

                <hr>

                <!-- ===================================================== -->
                <h3 id="demo-red-flags">9.3 Типовые «красные флаги»</h3>

                <ul>
                  <li>«Это лучше делать после внедрения»</li>
                  <li>«В реальном проекте мы бы сделали иначе»</li>
                  <li>«Здесь много нюансов, на демо не показать»</li>
                  <li>«Это делается, но нужен отдельный проект»</li>
                  <li>«Нужно посмотреть, как это повлияет на отчёты»</li>
                </ul>

                <p>
                  Эти фразы не означают,
                  что система плохая.
                  Они означают,
                  что стоимость изменений
                  пока неизвестна и неконтролируема.
                </p>

                <hr>

                <!-- ===================================================== -->
                <h3 id="demo-result">9.4 Что считать хорошим результатом пилота</h3>

                <p>
                  Хороший результат —
                  не «мы всё сделали»,
                  а следующее:
                </p>

                <ul>
                  <li>правило описано в одном месте или одном типе механизма;</li>
                  <li>видно, какие данные и расчёты оно затрагивает;</li>
                  <li>понятно, как проверить регресс;</li>
                  <li>изменение не требует «особого знания» конкретного человека.</li>
                </ul>

                <p>
                  Если после пилота можно ответить на вопрос
                  <strong>«сколько стоит следующее изменение»</strong>,
                  значит архитектура поддаётся управлению.
                </p>

              </section>
              <!-- ===================================================== -->
             <section class="post-content" id="conclusion">

              <h2 id="conclusion-title">10. Заключение</h2>

              <p>
                Этот разбор не про «хорошие» и «плохие» ERP.
                1С, SAP, Microsoft Dynamics и Odoo успешно работают в тысячах компаний.
                Проблемы начинаются не на этапе внедрения,
                а в момент, когда бизнес начинает <strong>менять правила</strong>.
              </p>

              <p>
                Архитектурные ограничения редко выглядят критичными по отдельности.
                Они накапливаются:
                через дополнительные проверки,
                частные доработки,
                исключения и временные обходы.
                Со временем именно они определяют реальную стоимость изменений.
              </p>

              <p>
                Ключевой вывод:
                <strong>дорогими становятся не сложные правила, а плохо формализованные</strong>.
                Когда логика распылена между объектами, формами, запросами,
                визуальными сценариями и интеграциями,
                система перестаёт быть управляемой как единое целое.
              </p>

              <p>
                В такой архитектуре возникает практический lock-in —
                не столько от вендора,
                сколько от конкретных людей,
                которые «помнят, как всё работает».
              </p>

              <p>
                Часто ожидается, что AI или low-code решат эту проблему.
                На практике происходит обратное:
                AI лишь ускоряет работу с уже существующим хаосом,
                если правила не описаны формально и однозначно.
              </p>

              <p>
                AI становится реальным активом только тогда,
                когда бизнес-логика выражена
                в <strong>структурированном, типизированном и логичном языке</strong>,
                подкреплённом документацией.
                В этом случае внутренняя команда может использовать AI
                для анализа правил, генерации процессов,
                оценки последствий изменений и сопровождения системы —
                без постоянной зависимости от вендора или отдельных специалистов.
              </p>

              <div class="callout" role="note">
                <strong>Итог</strong>
                <p>
                  Устойчивая ERP — это не та, где «всё можно настроить»,
                  а та, где стоимость следующего изменения
                  можно объяснить, проверить и спрогнозировать заранее.
                </p>
              </div>

            </section>




              <hr>

              <h2 id="sources">Источники и ссылки</h2>
              <ul>
                <li>
                  <a href="https://habr.com/ru/companies/lsfusion/articles/544982/" target="_blank" rel="noopener noreferrer">
                    “ERP, которая не ломается от изменений” (Хабр) ↗
                  </a>
                </li>
                <li>
                  <a href="https://habr.com/ru/companies/lsfusion/articles/468415/" target="_blank" rel="noopener noreferrer">
                    “Ограничения 1С:Предприятия” (Хабр) ↗
                  </a>
                </li>
              </ul>

              <h2 id="related-posts">Похожие статьи</h2>
              <div class="callout">
                <strong>Продолжить чтение:</strong>
                <p>
                  Если важны практические последствия архитектуры ERP и снижение зависимости от подрядчиков —
                  вот ещё материалы на DevLab Blog:
                </p>
                <ul>
                  <li>
                    <a href="https://ru.devlab.blog/posts/post13-open-source-erp-low-code.html" target="_blank" rel="noopener noreferrer">
                      Open-source ERP и low-code: какие бизнес-системы реально используют компании ↗
                    </a>
                  </li>
                  <li>
                    <a href="https://ru.devlab.blog/main-erp-stack-2032-ai-readable-architectures.html" target="_blank" rel="noopener noreferrer">
                      Почему ERP будущего будут модульными, декларативными и читаемыми для ИИ ↗
                    </a>
                  </li>
                </ul>
              </div>
            </section>

            <footer class="post-footer-extended">
              <div class="post-footer-meta">
                <div class="post-meta-tags">
                  <span class="post-tag">ERP</span>
                  <span class="post-tag">Архитектура</span>
                  <span class="post-tag">Сопровождение</span>
                  <span class="post-tag">1С</span>
                  <span class="post-tag">SAP</span>
                  <span class="post-tag">Dynamics</span>
                  <span class="post-tag">Odoo</span>
                  <span class="post-tag">Интеграции</span>
                  <span class="post-tag">Vendor lock-in</span>
                  <span class="post-tag">Low-code</span>
                </div>

                <div class="post-meta-secondary">
                  <span>Опубликовано: 22 янв 2026</span>
                  <span>·</span>
                  <span>Примерно 10–12 мин чтения</span>
                  <span>·</span>
                  <span class="post-views">Просмотры: <span class="count">—</span></span>
                </div>
              </div>
            </footer>

            <!-- Inline newsletter -->
            <section class="sidebar-block">
              <p class="sidebar-text">
                Без спама — только редкие заметки про ERP, автоматизацию и новые статьи.
              </p>
              <form class="newsletter-form"
                    action="https://formsubmit.co/info@devlab.blog"
                    method="POST">
                <input type="hidden" name="_next" value="https://ru.devlab.blog/thank-you.html">
                <input type="hidden" name="_captcha" value="false">
                <input type="text" name="_honey" style="display:none">

                <input type="email" name="email" class="field" placeholder="Ваш email" required>
                <button class="btn btn-primary" type="submit">Подписаться</button>

                <p class="newsletter-note">
                  Вы получите письмо подтверждения.<br>
                  Работает через FormSubmit.
                </p>
              </form>

              <h2 id="feedback">Быстрый фидбек</h2>
              <div class="callout">
                <strong>Было полезно?</strong>
                <p>Короткий сигнал помогает нам выбирать следующие темы.</p>

                <div class="hero-actions">
                  <button class="btn btn-primary" type="button" data-vote="like">
                    👍 Да <span class="count" data-count="like">—</span>
                  </button>

                  <button class="btn btn-outline" type="button" data-vote="dislike">
                    👎 Не особо <span class="count" data-count="dislike">—</span>
                  </button>
                </div>

                <p class="sidebar-text">Без комментариев и аккаунтов.</p>
              </div>
            </section>

            <div class="post-nav-links">
              <a class="back" href="/#posts" style="margin-left: 0;">← Назад ко всем статьям</a>
              <a class="back" href="/#categories" style="margin-right: 0;">Категории →</a>
            </div>
          </article>

          <!-- SIDEBAR -->
          <aside class="sidebar">
            <section class="sidebar-block">
              <h3 class="sidebar-title" id="topic-question-title">Предложить тему</h3>
              <p class="sidebar-text">
                Есть вопрос или идея для следующей статьи?
                <a class="post-read" href="mailto:info@devlab.blog?subject=Идея%20или%20вопрос%20для%20DevLab%20Blog">
                  Написать нам →
                </a>
              </p>
            </section>

            <section class="sidebar-block">
              <h3 class="sidebar-title">О блоге</h3>
              <p class="sidebar-text">
                DevLab Blog — заметки про open-source ERP, модульные подходы, интеграции и практику автоматизации.
                Пишем про то, что ломается в реальных внедрениях и как принимать технологические решения без “религии”.
              </p>
            </section>

            <section class="sidebar-block">
              <h3 class="sidebar-title">Ещё</h3>
              <p class="sidebar-text">
                Вернитесь на главную страницу или выберите категорию:
              </p>
              <ul>
                <li><a href="/">Все статьи</a></li>
                <li><a href="/#categories">Категории</a></li>
                <li><a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Главный сайт DevLab</a></li>
              </ul>
            </section>
          </aside>
        </div>
      </div>
    </main>

    <!-- FOOTER -->
    <footer class="site-footer">
      <div class="wrapper footer-grid">
        <div>
          <div class="footer-links">
            <a href="/">Статьи</a>
            <a href="/#categories">Категории</a>
            <a href="/#about">О блоге</a>
            <a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Главный сайт</a>
          </div>
          <p class="footer-meta">
            DevLab Blog – заметки про open-source ERP, модульные архитектуры и автоматизацию.
          </p>
        </div>
        <div class="footer-meta">
          <p>&copy; <span id="year"></span> DevLab Blog</p>
        </div>
      </div>
    </footer>
  </div>
</body>
</html>
