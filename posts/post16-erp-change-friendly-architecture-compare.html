<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ERP, которая не превращается в дорогой тормоз: ограничения 1С / SAP / Dynamics / Odoo – DevLab Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Разбор идеи из статьи на Хабре «ERP, которая не ломается от изменений»: почему ERP становится дорогой через 6–18 месяцев, где появляется lock-in, и как это проявляется в 1С / SAP / Dynamics / Odoo. Реальные мини-кейсы, таблица сравнения и вопросы для демо."
  />

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="https://uk.devlab.blog/img/devlab-logo.svg">
  <link rel="alternate icon" type="image/png" sizes="32x32" href="https://uk.devlab.blog/img/devlab-favicon-32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://uk.devlab.blog/img/devlab-favicon-180.png">

  <!-- Consent Mode (set BEFORE GTM) -->
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}

    gtag('consent','default',{
      analytics_storage:'denied',
      ad_storage:'denied',
      ad_user_data:'denied',
      ad_personalization:'denied',
      functionality_storage:'granted',
      security_storage:'granted'
    });
  </script>

  <!-- Main blog styles -->
  <link rel="stylesheet" href="https://uk.devlab.blog/style/devlab-style.css">

  <!-- Main blog scripts (year + search + views counter) -->
  <script src="https://uk.devlab.blog/js/script.js" defer></script>

  <!-- Structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://ru.devlab.blog/posts/post16-erp-change-friendly-architecture-compare.html"
    },
    "headline": "ERP, которая не превращается в дорогой тормоз: ограничения 1С / SAP / Dynamics / Odoo",
    "description": "Разбор идеи из статьи на Хабре «ERP, которая не ломается от изменений»: почему ERP становится дорогой через 6–18 месяцев, где появляется lock-in, и как это проявляется в 1С / SAP / Dynamics / Odoo. Реальные мини-кейсы, таблица сравнения и вопросы для демо.",
    "author": { "@type": "Organization", "name": "DevLab Blog" },
    "publisher": {
      "@type": "Organization",
      "name": "DevLab",
      "logo": { "@type": "ImageObject", "url": "https://uk.devlab.blog/img/devlab-logo.svg" }
    },
    "datePublished": "2026-01-22",
    "dateModified": "2026-01-22"
  }
  </script>

  <link rel="canonical" href="https://ru.devlab.blog/posts/post16-erp-change-friendly-architecture-compare.html">

  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WTZDV4K6');</script>
  <!-- End Google Tag Manager -->
</head>

<body class="post-page">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WTZDV4K6"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div class="page">
    <!-- HEADER -->
    <header>
      <div class="wrapper">
        <nav class="nav">
          <a href="/" class="nav-brand">
            <div class="nav-logo" aria-hidden="true">
              <img src="https://uk.devlab.blog/img/devlab-logo.svg" alt="DevLab Blog logo">
            </div>
            <div class="nav-meta">
              <div class="nav-meta-title">DevLab Blog</div>
              <div class="nav-meta-sub">Open-source ERP &amp; automation notes</div>
            </div>
          </a>

          <div class="nav-group">
            <div class="nav-links">
              <a href="/#posts">Статьи</a>
              <a href="/#categories">Категории</a>
              <a href="/#about">О блоге</a>
              <a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Главный сайт</a>
            </div>
            <div class="nav-lang">
              <a href="https://en.devlab.blog/">EN</a>
              <a href="https://pl.devlab.blog/">PL</a>
              <a href="https://ru.devlab.blog/" class="active">RU</a>
              <a href="https://uk.devlab.blog/">UA</a>
            </div>
          </div>

          <div class="nav-cta">
            <a href="/#posts" class="btn btn-outline">Все статьи</a>
            <a href="/#about" class="btn btn-primary">Что это?</a>
          </div>

          <button class="nav-toggle" aria-label="Toggle navigation">☰</button>
        </nav>
      </div>
    </header>

    <!-- MAIN -->
    <main>
      <div class="wrapper">
        <div class="main-grid">
          <!-- ARTICLE -->
          <article id="post16-erp-change-friendly-architecture-compare">
            <div class="section-title">
              <span>Статья</span>
              <small><a class="back" href="/">← Назад ко всем статьям</a></small>
            </div>

            <header>
              <div class="post-meta">
                <span>ERP · Практика управления изменениями</span>
                <span>&middot;</span>
                <span>Примерно 10–12 мин чтения</span>
                <span>&middot;</span>
                <span>Для собственников и руководителей</span>
              </div>

              <h1 class="hero-title">
                ERP, которая не превращается в дорогой тормоз:  </h1>
                <h2>анализ архитектуры 1С / SAP / Dynamics / Odoo</h2>
             
                <p>
                Если на запуске ERP “едет” — это ещё не успех. Это скорее стандартная ситуация.
                На старте процессы часто подгоняют под систему, команда мотивирована, нагрузка прогнозируемая,
                а часть неудобных правил откладывают “на потом”.
              </p>
              <p>
                Настоящая проверка начинается позже — когда бизнес делает то, ради чего ERP вообще нужна:
                <strong>меняет правила управления компанией без потери контроля</strong>
              </p>

              <ul>
                <li>новая схема скидок или бонусов;</li>
                <li>новые типы договоров и оплата “как в жизни” (предоплата/постоплата/этапы);</li>
                <li>новые ограничения по рискам и кредитным лимитам;</li>
                <li>новые маршруты согласования по логике (а не “по должности”);</li>
                <li>новые каналы продаж и новая аналитика прибыли;</li>
                <li>пересборка интеграций (CRM, WMS, маркетплейсы, BI).</li>
              </ul>

              <figure class="post-hero">
                <img
                  src="https://uk.devlab.blog/img/post16-erp-architecture-doesnt-break-compare-1c-sap-dynamics-odoo.webp"
                  alt="ERP без боли от изменений: правила бизнеса, контроль стоимости изменений, предсказуемая эволюция системы"
                  loading="lazy"
                  decoding="async"
                >
              </figure>
            </header>

            <section class="post-content">
            <div class="callout">
              <strong>По мотивам технических статей на Хабре</strong>
              <p>
                Этот материал — независимый разбор архитектурных ограничений ERP на основе двух статей:
                <a href="https://habr.com/ru/companies/lsfusion/articles/544982/" target="_blank" rel="noopener noreferrer">
                  “ERP, которая не ломается от изменений” ↗
                </a>
                и
                <a href="https://habr.com/ru/companies/lsfusion/articles/468415/" target="_blank" rel="noopener noreferrer">
                  “Ограничения 1С:Предприятия” ↗
                </a>.
                Мы не оцениваем “какая ERP лучше”. Мы берём <strong>каждый тезис пункт-в-пункт</strong> и показываем,
                <strong>как это обычно выглядит в 1С / SAP / Dynamics / Odoo</strong> — и почему “архитектура” внезапно
                становится проблемой руководителей, когда бизнес начинает менять правила.
              </p>
            </div>

  <h2 id="how-to-read">Как читать этот разбор</h2>
  <p>
    Каждый пункт ниже — это <strong>архитектурное ограничение</strong>, которое проявляется не сразу.
    Сначала оно выглядит как “особенность платформы”, потом — как “нужна доработка”, а ещё позже —
    как “почему у нас любое изменение превращается в мини-проект”.
  </p>

  <p>
    Формат один и тот же:
  </p>

  <ul>
    <li><strong>Что имеется в виду</strong> (коротко и технически)</li>
    <li><strong>Как это обычно выглядит в 1С</strong></li>
    <li><strong>Как это обычно выглядит в SAP</strong></li>
    <li><strong>Как это обычно выглядит в Microsoft Dynamics</strong></li>
    <li><strong>Как это обычно выглядит в Odoo</strong></li>
    <li><strong>К чему это приводит на практике</strong> (не маркетинг — наблюдение из проектов)</li>
  </ul>

  <hr>
<h2 id="p1-objects">Ограничение 1. Объекты: справочники, документы и т.д.</h2>
<p>
  В классических ERP объектная модель выглядит естественно: есть справочники, документы, регистры, формы и отчёты.
  Проблема начинается не с наличия объектов, а когда <strong>объект становится центром архитектуры</strong>,
  а правила управления компанией расползаются по слоям: в формах, обработчиках, отчётах, интеграциях и правах доступа.
</p>

<div class="callout">
  <strong>Ядро идеи из Хабра (в терминах эксплуатации)</strong>
  <p>
    Система хуже переносит изменения, когда правила не описаны как единая логика,
    а “зашиты” в поведение отдельных объектов и их обработчиков. Тогда правка одного правила начинает цеплять всё вокруг:
    отчётность, интеграции, контроль и доступы.
  </p>
</div>

<table>
  <thead>
    <tr>
      <th>Система</th>
      <th>Как обычно выглядит на практике</th>
      <th>Как это проявляется в управлении</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1С</strong></td>
      <td>Метаданные (Справочники/Документы/Регистры) + обработчики проведения + логика форм + запросы в отчётах + “исторические исключения”.</td>
      <td>Правила трудно локализовать: “где это меняется?” → изменения идут цепочкой правок.</td>
    </tr>
    <tr>
      <td><strong>SAP</strong></td>
      <td>Логика распределяется между настройками, расширениями (exit/BAdI и т.п.), workflow, интеграциями, моделями данных/представлениями.</td>
      <td>Правило становится композицией фрагментов: сложно быстро объяснить причинность и влияние правок.</td>
    </tr>
    <tr>
      <td><strong>Dynamics</strong></td>
      <td>Entities + конфигурационные правила + плагины/скрипты + Power Automate/workflows + коннекторы.</td>
      <td>При росте числа правил логика “распыляется”, объяснимость падает, изменения становятся менее предсказуемыми.</td>
    </tr>
    <tr>
      <td><strong>Odoo</strong></td>
      <td>ORM-модели + модули; деградация начинается при большом числе модулей/пересечений правил и конфликтов обновлений с кастомом.</td>
      <td>Устойчивость к изменениям зависит от дисциплины модульности и контроля зависимостей.</td>
    </tr>
  </tbody>
</table>

<p>
  <strong>Что обычно ломается:</strong> одно “простое правило” требует правок в нескольких местах; сложнее объяснять “почему получилось так”;
  логика превращается в “историю внедрения”, а не в управляемую модель.
</p>

<hr>

<h2 id="p2-data-fetch">Ограничение 2. Неэффективное получение данных объектов</h2>
<p>
  Типичный симптом объектной архитектуры: системе трудно получить данные ровно в том виде, в котором они нужны логике.
  Вместо одного оптимального запроса появляются цепочки запросов, чтение объектов в циклах и постобработка в коде.
</p>

<table>
  <thead>
    <tr>
      <th>Система</th>
      <th>Как это выглядит</th>
      <th>Что это даёт бизнесу</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1С</strong></td>
      <td>Часть данных — запросом, часть — через объект (ПолучитьОбъект/Прочитать/Записать), часть — внутри обработчиков.</td>
      <td>“Простой” отчёт/проверка превращается в десятки обращений; тормоза проявляются после роста объёма данных.</td>
    </tr>
    <tr>
      <td><strong>SAP</strong></td>
      <td>Данные доступны, но команды теряют контроль над фактическими выборками из-за уровней моделей/расширений/интеграций.</td>
      <td>Появляются тяжёлые выборки “на всякий случай”, и правки в аналитике становятся рискованными.</td>
    </tr>
    <tr>
      <td><strong>Dynamics</strong></td>
      <td>ORM/API-подход: легко получить много мелких обращений вместо одного, особенно при разделении UI/плагины/workflow.</td>
      <td>Скорость деградирует не сразу; потом “внезапно всё стало медленно”, и начинаются обходы/витрины.</td>
    </tr>
    <tr>
      <td><strong>Odoo</strong></td>
      <td>Классическая проблема ORM: N+1 запросы и скрытые дорогие вычисления.</td>
      <td>До роста данных не видно; после — требуется ручной тюнинг и переписывание логики.</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Производительность деградирует через 6–12 месяцев, а не на старте.</li>
  <li>Любая новая аналитика требует ручной оптимизации.</li>
  <li>Изменения становятся непредсказуемыми по нагрузке → команды начинают “бояться правок”.</li>
</ul>

<hr>

<h2 id="p3-registers">Ограничение 3. Таблицы/представления: регистры</h2>
<p>
  Регистры — попытка построить аналитический слой над объектной моделью: остатки, движения, агрегаты.
  Архитектурный конфликт в том, что часто возникает <strong>“второй мир”</strong>:
  операции живут в документах, а аналитическая “правда” — в регистрах/витринах, и синхронизация становится отдельной задачей.
</p>

<table>
  <thead>
    <tr>
      <th>Система</th>
      <th>Аналог “регистров”</th>
      <th>Риск</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1С</strong></td>
      <td>Регистры — ключевой механизм, но часть правил всё равно остаётся в коде объектов/обработчиках.</td>
      <td>Двойная логика: “по регистрам одно, по документам другое”.</td>
    </tr>
    <tr>
      <td><strong>SAP</strong></td>
      <td>Движения + агрегаты + представления/аналитические модели (зависит от ландшафта).</td>
      <td>“Что считать истиной?” становится договорённостью между слоями.</td>
    </tr>
    <tr>
      <td><strong>Dynamics</strong></td>
      <td>Часто уходит в BI/витрины/Power BI, потому что транзакционный контур не закрывает управленческую правду целиком.</td>
      <td>Управленческие метрики живут отдельно от правил транзакций.</td>
    </tr>
    <tr>
      <td><strong>Odoo</strong></td>
      <td>Часть агрегатов решается модульной логикой; дальше появляются отчёты/SQL views/внешние BI-контуры.</td>
      <td>Риск “двойной правды” растёт по мере усложнения управления.</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Операции ≠ управленческие цифры (двойная правда).</li>
  <li>Правила меняются в одном слое, а агрегаты — в другом.</li>
  <li>Любое изменение требует синхронной правки “двух миров”.</li>
</ul>

<hr>

<h2 id="p4-registers-narrow">Ограничение 4. Регистры поддерживаются только в частных случаях</h2>
<p>
  Даже при наличии аналитического слоя он обычно рассчитан на “правильные” типовые сценарии.
  Как только бизнес-логика выходит за рамки — команда уходит в ручную реализацию, и правила теряют прозрачность.
</p>

<ul>
  <li><strong>1С:</strong> “по учебнику” работает отлично, но нетипичные расчёты/исключения быстро уходят в код и перестают быть прозрачными.</li>
  <li><strong>SAP:</strong> типовой бизнес закрывается, нетиповые контуры превращаются в расширения/интеграционную логику/отдельные витрины.</li>
  <li><strong>Dynamics:</strong> при росте автоматизаций сложнее удерживать единые показатели и контроль в одном месте.</li>
  <li><strong>Odoo:</strong> модуль даёт хороший сценарий, но расширение — вопрос поддержки кастома через обновления.</li>
</ul>

<p>
  Итог: часть контроля становится “ручной”, ERP превращается в набор частных решений, а стоимость сопровождения растёт именно из-за нестандартных сценариев
  (которые в любой компании неизбежны).
</p>

<hr>

<h2 id="p5-register-events">Ограничение 5. Нет ограничений и событий для значений регистров</h2>
<p>
  В управлении часто нужны правила, завязанные на агрегаты: задолженность vs лимит, остатки, маржа, риск.
  В ряде платформ такие правила не являются “первоклассными”: их приходится собирать вручную.
</p>

<div class="callout">
  <strong>Практическая формулировка</strong>
  <p>
    “Запретить действие до операции, если агрегат нарушен” — сложнее, чем “поймать проблему после факта”.
    Именно тут чаще всего появляется ручной контроль и исключения.
  </p>
</div>

<ul>
  <li><strong>1С:</strong> проверки обычно в момент проведения/отдельных процедурах контроля → правило становится кодом, сложнее переиспользовать и безопасно менять.</li>
  <li><strong>SAP:</strong> часто комбинация настроек + расширений + workflow → контроль сильный, но цена изменений высокая из-за нескольких слоёв.</li>
  <li><strong>Dynamics:</strong> плагины/асинхронные автоматизации → риск, если нужно строгое “до операции”.</li>
  <li><strong>Odoo:</strong> constraints кодом возможны, но агрегаты = вычисления/нагрузка/гонки данных/сложность поддержки.</li>
</ul>

<ul>
  <li>Контроль превращается в скрипт, а не часть модели.</li>
  <li>Правила теряют объяснимость (“почему запретило/почему пропустило”).</li>
  <li>Бизнес уходит в режим “исключения + ручная проверка”.</li>
</ul>

<hr>

<h2 id="p6-virtual-tables">Ограничение 6. В параметрах виртуальных таблиц можно использовать только константы</h2>
<p>
  Звучит узко, но в итоге означает: сложнее подать в выборку контекст (текущая операция, пользователь, сценарий, динамические условия).
  Компромисс обычно один: либо выбираем “слишком широко” и фильтруем руками, либо плодим сущности “под кейс”, либо уводим расчёт в код.
</p>

<ul>
  <li><strong>1С:</strong> виртуальные таблицы активно используются, но динамическая параметризация часто ограничена → логика уходит из запроса в прикладной слой.</li>
  <li><strong>SAP:</strong> параметризация богаче, но условия нередко расползаются между моделями данных и логикой приложения.</li>
  <li><strong>Dynamics:</strong> “умный запрос” часто распадается на несколько обращений через API/ORM + фильтрация на клиенте.</li>
  <li><strong>Odoo:</strong> домены/контекст гибкие, но сложные условия нередко ведут к трудноотлаживаемым сценариям и дорогим выборкам.</li>
</ul>

<p>
  Эффект: система хуже оптимизируется, отчёты и проверки начинают расходиться по логике, появляются копии “почти одинаковых” решений.
</p>

<hr>

<h2 id="p7-queries">Ограничение 7. Запросы как отдельный слой системы</h2>
<p>
  Этот пункт — про то, насколько ERP позволяет выражать правила и аналитику на уровне данных.
  Когда запросный слой слабый, логика распадается: часть живёт “в запросах”, часть — в постобработке кода.
  Со временем становится неясно, где именно определено правило.
</p>

<ul>
  <li><strong>1С:</strong> базовые вещи покрываются, но сложные показатели и массовые операции часто превращаются в гибрид “запрос + обработка”.</li>
  <li><strong>SAP:</strong> запросный слой сильнее, но правило часто требует правок в нескольких слоях (настройки/расширения/модели/интеграции).</li>
  <li><strong>Dynamics:</strong> сложные выборки возможны, но оптимизация и стоимость исполнения растут → побеждают витрины/BI.</li>
  <li><strong>Odoo:</strong> ORM + точечный SQL создают гибрид, который трудно сопровождать, если нет дисциплины.</li>
</ul>

<hr>

<h2 id="p8-string-queries">Ограничение 8. Запросы в строках</h2>
<p>
  Когда запрос — это строка внутри кода, ухудшается всё, что связано с сопровождением:
  рефакторинг, статический анализ, поиск зависимостей, проверяемость, предсказуемость изменений.
</p>

<ul>
  <li><strong>1С:</strong> классика: запросы компонуются текстом → ошибки ловятся в рантайме, запросы копируются и расходятся.</li>
  <li><strong>SAP/Dynamics/Odoo:</strong> аналогичные эффекты возникают, когда сложные условия выражаются текстовыми выражениями/скриптами/точечным raw SQL.</li>
</ul>

<p>
  Итог: растёт число неявных зависимостей и усиливается эффект “не трогать — сломаем отчёты”.
  Для AI-ассистирования это тоже минус: строковый запрос без контекста он скорее “угадывает”, чем понимает.
</p>

<hr>

<h2 id="p9-no-optimizer">Ограничение 9. Отсутствие (или слабость) оптимизации запросов</h2>
<p>
  Слабая оптимизация означает простую управленческую реальность: отчёт/проверка “летит” на тестовых данных и падает на реальных.
  Тогда аналитика становится не функцией ERP, а отдельным проектом по ручному тюнингу.
</p>

<ul>
  <li><strong>1С:</strong> “в тесте быстро, в проде умерло” → переписывание запросов, индексы, обходы.</li>
  <li><strong>SAP:</strong> сильные СУБД помогают, но сложные ландшафты и модели тоже требуют экспертизы и дисциплины.</li>
  <li><strong>Dynamics:</strong> сложную аналитику часто проще вынести в BI, чем выжимать оптимальные планы из платформы.</li>
  <li><strong>Odoo:</strong> СУБД может быть сильной, но ORM/прикладной слой генерируют неочевидно дорогие сценарии.</li>
</ul>

<hr>

<h2 id="p10-sql-features">Ограничение 10. Отсутствие расширенных SQL-возможностей</h2>
<p>
  Под “расширенными возможностями” обычно имеются в виду не “фичи ради фич”, а инструменты для реальной управленческой логики:
  оконные функции, CTE, условные агрегаты, массовые трансформации данных без циклов.
  Когда этого нет или доступно только обходами — расчёты уходят в прикладной код, а значит хуже оптимизируются и хуже трассируются.
</p>

<ul>
  <li><strong>1С:</strong> сложные выборки превращаются в несколько запросов + временные конструкции + циклы → логика расползается.</li>
  <li><strong>SAP:</strong> возможности обычно богаче, но цена — сложность модели и зависимость от правильной архитектуры слоёв.</li>
  <li><strong>Dynamics:</strong> богатую аналитику часто уводят в BI/витрины.</li>
  <li><strong>Odoo:</strong> SQL возможен, но команды часто ограничивают raw SQL ради поддержки → снова появляется гибридный стиль.</li>
</ul>

<p>
  Итог: неясно “где считается показатель”, сложнее безопасно менять правила, растёт стоимость сопровождения.
</p>

  <!-- ===================================================== -->
  <h2 id="limit-1-objects">Ограничение 1. Объекты: справочники, документы и т.д.</h2>

  <p>
    В классических ERP объектная модель выглядит “естественно”: есть справочники, документы, регистры,
    есть формы и отчёты. Проблема начинается не с наличия объектов — а с того, что
    <strong>объект становится “центром архитектуры”</strong>, и бизнес-логика начинает расползаться по слоям:
    в формах, обработчиках, отчётах, интеграциях, правах доступа.
  </p>

  <div class="callout">
    <strong>Ключевая идея из статей</strong>
    <p>
      Система плохо переносит изменения, если “правила бизнеса” не описаны как единая логика,
      а спрятаны в поведении отдельных объектов и их обработчиках.
      Тогда изменение одного правила начинает цеплять всё вокруг.
    </p>
  </div>

  <h3 id="limit-1-1c">Как это выглядит в 1С</h3>
  <p>
    1С строится вокруг объектов метаданных: <strong>Справочники / Документы / Регистры</strong>.
    С точки зрения разработчика это удобно на старте: всё “лежит по папкам”.
    Но типичная деградация начинается тогда, когда бизнес-правила реализуются не как “правило”,
    а как смесь:
  </p>
  <ul>
    <li>обработчиков проведения документа,</li>
    <li>логики формы,</li>
    <li>запросов в отчётах,</li>
    <li>проверок прав,</li>
    <li>скрытых “исключений” (исторически добавленных условий).</li>
  </ul>

  <h3 id="limit-1-sap">Как это выглядит в SAP</h3>
  <p>
    SAP менее “прямолинейно объектный”, но в больших ландшафтах проблема похожая:
    бизнес-логика распределяется между несколькими уровнями:
  </p>
  <ul>
    <li>стандартными объектами и настройками,</li>
    <li>расширениями (user exits / BAdI и т.п.),</li>
    <li>workflow-слоем,</li>
    <li>интеграционными точками,</li>
    <li>аналитическими представлениями (CDS и пр.).</li>
  </ul>
  <p>
    В результате “правило” часто становится не единым описанием, а композицией фрагментов,
    распределённых по системе.
  </p>

  <h3 id="limit-1-dynamics">Как это выглядит в Microsoft Dynamics</h3>
  <p>
    В Dynamics (особенно в CRM/Dataverse подходе) центром являются <strong>Entities</strong>,
    вокруг которых растёт слой автоматизаций:
  </p>
  <ul>
    <li>бизнес-правила в конфигурации,</li>
    <li>плагины/скрипты,</li>
    <li>Power Automate / workflows,</li>
    <li>интеграции и коннекторы.</li>
  </ul>
  <p>
    На старте это выглядит гибко. Но при росте количества правил появляется знакомый эффект:
    бизнес-логика “распылена”, и руководству сложно понять,
    <strong>почему система повела себя так, а не иначе</strong>.
  </p>

  <h3 id="limit-1-odoo">Как это выглядит в Odoo</h3>
  <p>
    Odoo моделирует всё через ORM-модели и модули. Формально это “модульно”.
    На практике ограничения появляются, когда:
  </p>
  <ul>
    <li>модулей становится много,</li>
    <li>правила пересекаются между модулями,</li>
    <li>настройки и кастомизация реализуются в разном стиле,</li>
    <li>обновления начинают конфликтовать с кастомом.</li>
  </ul>
  <p>
    То есть объектная модель “держится”, но переносимость изменений зависит от дисциплины разработки.
  </p>

  <h3 id="limit-1-practice">Что обычно ломается на практике</h3>
  <p>
    Когда объект становится центром архитектуры, компания сталкивается с тем, что:
  </p>
  <ul>
    <li>изменение “простого правила” требует правок в нескольких местах,</li>
    <li>сложно объяснять причинность (почему скидка/маржа/лимит именно такие),</li>
    <li>логика перестаёт быть управляемой и превращается в “историю внедрения”.</li>
  </ul>

  <hr>

  <!-- ===================================================== -->
  <h2 id="limit-2-data-fetch">Ограничение 2. Неэффективное получение данных объектов</h2>

  <p>
    В статье речь о том, что в объектной архитектуре “естественное” чтение данных часто получается неэффективным:
    система не умеет <strong>получить данные ровно в том виде, в котором они нужны логике</strong>,
    и разработчик начинает собирать картину вручную.
  </p>

  <p>
    Классический симптом: вместо одного оптимального запроса получается либо
    <strong>цепочка запросов</strong>, либо
    <strong>чтение объектов в циклах</strong>.
  </p>

  <h3 id="limit-2-1c">1С</h3>
  <p>
    В 1С это проявляется очень узнаваемо:
  </p>
  <ul>
    <li>часть данных читается запросом,</li>
    <li>часть — “через объект” (ПолучитьОбъект/Записать/Прочитать),</li>
    <li>часть — внутри обработчиков, где уже нет нормального контекста оптимизации.</li>
  </ul>
  <p>
    Итог: даже когда отчёт “вроде бы простой”, он может собираться из десятков обращений к данным,
    а тормоза проявятся только при росте объёма.
  </p>

  <h3 id="limit-2-sap">SAP</h3>
  <p>
    В SAP проблема часто выглядит иначе: данные есть, SQL мощный,
    но архитектурно доступ к данным проходит через уровни, и разработчик/команда:
  </p>
  <ul>
    <li>теряет контроль над фактическими запросами,</li>
    <li>получает тяжёлые выборки “на всякий случай”,</li>
    <li>боится менять запросы, потому что неясно, кто ещё зависит от этих объектов.</li>
  </ul>

  <h3 id="limit-2-dynamics">Dynamics</h3>
  <p>
    Для Dynamics типична ORM-природа: часто получается много обращений вместо одного.
    Особенно если логика размазана между:
  </p>
  <ul>
    <li>клиентом (UI),</li>
    <li>плагинами,</li>
    <li>workflow-автоматизациями,</li>
    <li>интеграциями.</li>
  </ul>

  <h3 id="limit-2-odoo">Odoo</h3>
  <p>
    Odoo даёт удобный ORM, но у ORM есть классическая болезнь:
    <strong>N+1 запрос</strong> и скрытые “дорогие” вычисления.
    В небольших данных это не видно. При росте — внезапно “всё стало медленно”.
  </p>

  <h3 id="limit-2-practice">К чему это приводит</h3>
  <ul>
    <li>Система внезапно деградирует по скорости через 6–12 месяцев.</li>
    <li>Любая новая аналитика требует “ручного тюнинга”.</li>
    <li>Команда боится изменений, потому что изменения непредсказуемо влияют на нагрузку.</li>
  </ul>

  <hr>

  <!-- ===================================================== -->
  <h2 id="limit-3-registers">Ограничение 3. Таблицы / Представления: регистры</h2>

  <p>
    Регистры в контексте статьи — это попытка создать “аналитический слой” поверх объектной модели,
    чтобы можно было быстро получать агрегаты, остатки, движения и т.д.
  </p>

  <p>
    Архитектурный конфликт в том, что регистры часто являются <strong>вторым миром</strong>:
    операции живут в документах, а аналитическая правда — в регистрах,
    и синхронизация между ними со временем становится отдельной проблемой.
  </p>

  <h3 id="limit-3-1c">1С</h3>
  <p>
    В 1С регистры — ключевая часть платформы, но они решают далеко не всё:
  </p>
  <ul>
    <li>часть логики остаётся в коде объектов и обработчиков,</li>
    <li>не всё удобно выражается через регистры,</li>
    <li>часто появляются “особые случаи”, которые регистр не закрывает без костылей.</li>
  </ul>

  <h3 id="limit-3-sap">SAP</h3>
  <p>
    В SAP аналог “регистров” часто реализован через:
  </p>
  <ul>
    <li>таблицы движения + агрегаты,</li>
    <li>аналитические представления,</li>
    <li>CDS Views,</li>
    <li>отдельные контуры отчётности.</li>
  </ul>
  <p>
    Конфликт возникает там же: бизнес-логика распределяется между уровнями,
    и “что считать правдой” становится вопросом договорённостей, а не системы.
  </p>

  <h3 id="limit-3-dynamics">Dynamics</h3>
  <p>
    В Dynamics “регистровость” часто уходит в:
  </p>
  <ul>
    <li>отдельные отчётные хранилища,</li>
    <li>Power BI,</li>
    <li>интеграции и витрины.</li>
  </ul>
  <p>
    То есть агрегаты чаще живут вне основного транзакционного контура.
  </p>

  <h3 id="limit-3-odoo">Odoo</h3>
  <p>
    В Odoo часть агрегатов и остатков решается внутри логики модулей.
    Но как только требуется “правда” не только для операций, но и для управления,
    появляются:
  </p>
  <ul>
    <li>кастомные отчёты,</li>
    <li>SQL views,</li>
    <li>внешние BI-контуры.</li>
  </ul>

  <h3 id="limit-3-practice">К чему это приводит</h3>
  <ul>
    <li>Появляется “двойная правда”: операции ≠ управленческие цифры.</li>
    <li>Агрегаты начинают жить отдельно от правил.</li>
    <li>Изменения правил требуют синхронных изменений в “двух слоях”.</li>
  </ul>

  <hr>

  <!-- ===================================================== -->
  <h2 id="limit-4-registers-narrow">Ограничение 4. Регистры поддерживаются в очень частных случаях</h2>

  <p>
    Этот пункт про то, что даже если аналитический слой существует, он поддерживает
    <strong>узкий набор “правильных” сценариев</strong>. Как только бизнес-логика выходит за рамки этих сценариев —
    разработчик снова уходит в ручную реализацию.
  </p>

  <h3 id="limit-4-1c">1С</h3>
  <p>
    Типовая ситуация: стандартные регистры отлично работают, пока всё “по учебнику”.
    Но как только появляются:
  </p>
  <ul>
    <li>нетипичные схемы расчётов,</li>
    <li>сложные исключения,</li>
    <li>нестандартные условия перехода состояний,</li>
  </ul>
  <p>
    — часть логики уходит в код и перестаёт быть прозрачной для системы.
  </p>

  <h3 id="limit-4-sap">SAP</h3>
  <p>
    В SAP похожий эффект: мощная база позволяет многое,
    но стандартные модели рассчитаны на “типовой бизнес”.
    Любой нетиповой контур превращается в:
  </p>
  <ul>
    <li>доработки,</li>
    <li>расширения,</li>
    <li>интеграционную логику,</li>
    <li>или отдельный контур (например, отдельная витрина данных).</li>
  </ul>

  <h3 id="limit-4-dynamics">Dynamics</h3>
  <p>
    В Dynamics ограничения чаще не “в теории”, а в практике эксплуатации:
    чем больше логики вынесено в automation-слой, тем сложнее сделать так,
    чтобы агрегаты и контрольные показатели оставались едиными.
  </p>

  <h3 id="limit-4-odoo">Odoo</h3>
  <p>
    В Odoo этот пункт обычно проявляется так:
    модуль даёт хороший “типовой сценарий”, но расширение логики требует вмешательства в код,
    и дальше вопрос уже не в “возможности”, а в том, как поддерживать этот кастом через обновления.
  </p>

  <h3 id="limit-4-practice">К чему это приводит</h3>
  <ul>
    <li>Часть управления и контроля становится “ручной”.</li>
    <li>Система перестаёт быть единым механизмом — она становится набором частных решений.</li>
    <li>Растёт цена сопровождения именно из-за нестандартных сценариев (а они всегда появятся).</li>
  </ul>

  <hr>

  <!-- ===================================================== -->
  <h2 id="limit-5-no-constraints-events">Ограничение 5. Отсутствие ограничений и событий для значений регистров</h2>

  <p>
    Здесь ключевой момент очень конкретный:
    бизнес часто хочет правила вида:
  </p>

  <ul>
    <li>“Если суммарная задолженность клиента &gt; лимита — запретить отгрузку”,</li>
    <li>“Если остаток на складе стал отрицательным — не проводить документ”,</li>
    <li>“Если маржа по заказу &lt; X — отправить на согласование”,</li>
  </ul>

  <p>
    То есть правила завязаны не на поля одного объекта, а на <strong>агрегированные значения</strong>.
    Проблема в том, что в ряде платформ такие правила не являются “первоклассными”:
    их нужно реализовывать вручную.
  </p>

  <h3 id="limit-5-1c">1С</h3>
  <p>
    В 1С контроль регистровых значений обычно реализуется как:
  </p>
  <ul>
    <li>проверка в момент проведения документа,</li>
    <li>или отдельные процедуры контроля,</li>
    <li>или “обработка ошибок вручную”.</li>
  </ul>
  <p>
    Это работает, но приводит к типовой проблеме:
    <strong>правило становится кодом</strong>, а не частью модели.
    Поэтому его сложно переиспользовать, тестировать и безопасно менять.
  </p>

  <h3 id="limit-5-sap">SAP</h3>
  <p>
    В SAP подобные проверки обычно строятся через комбинацию:
  </p>
  <ul>
    <li>настроек,</li>
    <li>расширений,</li>
    <li>workflow,</li>
    <li>и (часто) внешних контуров контроля.</li>
  </ul>
  <p>
    В результате контроль может быть сильным, но цена его изменения обычно высокая:
    потому что он завязан на несколько слоёв.
  </p>

  <h3 id="limit-5-dynamics">Dynamics</h3>
  <p>
    В Dynamics ограничения на агрегаты часто превращаются в:
  </p>
  <ul>
    <li>плагины,</li>
    <li>асинхронные автоматизации,</li>
    <li>проверки “после факта”.</li>
  </ul>
  <p>
    Это особенно опасно для сценариев, где нужно строгое правило “до операции”,
    а не “поймать проблему потом”.
  </p>

  <h3 id="limit-5-odoo">Odoo</h3>
  <p>
    В Odoo ограничения можно писать кодом (constraints), но проблема в том, что
    контроль агрегатов часто требует дополнительных вычислений и запросов,
    а значит:
  </p>
  <ul>
    <li>это нагрузка,</li>
    <li>это риск гонок данных,</li>
    <li>это сложность поддержки через обновления.</li>
  </ul>

  <h3 id="limit-5-practice">К чему это приводит</h3>
  <ul>
    <li>Контроль становится “скриптом”, а не частью системы.</li>
    <li>Правила теряют прозрачность и объяснимость.</li>
    <li>Бизнес быстро начинает жить в режиме “исключения и ручной контроль”.</li>
  </ul>

  <hr>

<!-- ===================================================== -->
<h2 id="limit-6-virtual-params-constants">Ограничение 6. В параметрах виртуальных таблиц можно использовать только константы</h2>

<p>
  Этот пункт звучит “узко”, но на практике означает очень простую боль:
  <strong>нельзя гибко управлять выборкой данных под конкретный контекст</strong>
  (пользователь, текущий документ, режим работы, сложные условия).
</p>

<p>
  В идеальном мире ERP-платформа позволяет сделать запрос вида:
  “дай мне остатки/движения/показатели <strong>для этих объектов</strong> с учётом <strong>этого набора условий</strong>”.
  В реальности ограничения уровня “только константы” часто превращают это в компромисс:
</p>

<ul>
  <li>или делаем “универсальную” выборку и потом фильтруем руками,</li>
  <li>или делаем кучу почти одинаковых отчётов/обработок “под кейс”,</li>
  <li>или переносим расчёты в код.</li>
</ul>

<h3 id="limit-6-1c">1С</h3>
<p>
  В 1С виртуальные таблицы используются активно (остатки, обороты и т.п.),
  но их параметры часто ограничены именно таким образом:
  для многих сценариев нельзя подставить в параметры “динамическое условие”, которое вычисляется в ходе логики.
</p>

<p>
  Итог типовой:
  запрос становится слишком “общим”, а фильтрация и логика начинают жить вне базы данных.
  То есть нагрузка и сложность уходят в прикладной слой.
</p>

<h3 id="limit-6-sap">SAP</h3>
<p>
  В SAP аналогичные задачи чаще закрываются через SQL/CDS/аналитику.
  Параметризация есть, но архитектурное ограничение обычно другое:
  сложные условия часто “расползаются” между CDS, логикой приложения и аналитикой.
</p>

<p>
  То есть гибкость выше, но риск всё равно похожий:
  когда правило сложно выразить чисто в модели данных, оно начинает жить в нескольких местах.
</p>

<h3 id="limit-6-dynamics">Dynamics</h3>
<p>
  В Dynamics проблема проявляется в том, что “умный запрос” часто превращается в:
</p>
<ul>
  <li>несколько запросов через API/ORM,</li>
  <li>фильтрацию на стороне клиента,</li>
  <li>или отдельный pipeline обработки.</li>
</ul>

<p>
  То есть формально “данные достать можно”, но цена точности и скорости растёт.
</p>

<h3 id="limit-6-odoo">Odoo</h3>
<p>
  В Odoo обычно можно выразить условия динамически, но появляются другие компромиссы:
</p>
<ul>
  <li>часть логики проще сделать Python-циклом, чем запросом,</li>
  <li>ORM генерирует не всегда оптимальные выборки,</li>
  <li>сложные домены и контекст приводят к трудноотлаживаемым сценариям.</li>
</ul>

<h3 id="limit-6-practice">К чему это приводит</h3>
<ul>
  <li>Система становится сложной для оптимизации: данные читаются “широко”, потом фильтруются вручную.</li>
  <li>Отчёты и проверки правил начинают вести себя по-разному в разных местах.</li>
  <li>Любая новая логика превращается в “копию плюс исключение”.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-7-queries">Ограничение 7. Запросы (как отдельный слой системы)</h2>

<p>
  Этот блок в статьях подводит к важной мысли:
  ERP живёт не только объектами, но и тем, насколько <strong>эффективно и безопасно</strong>
  она умеет формировать запросы к данным.
</p>

<p>
  Когда запросный слой слабый, возникает классическая ситуация:
  разработчик получает два варианта — либо писать сложную логику в коде,
  либо городить “почти SQL”, который трудно поддерживать.
</p>

<h3 id="limit-7-1c">1С</h3>
<p>
  У 1С есть собственный язык запросов, и он закрывает базовые вещи.
  Но проблема возникает там, где нужно:
</p>
<ul>
  <li>сложное вычисление показателей,</li>
  <li>динамическая аналитика,</li>
  <li>универсальные правила контроля,</li>
  <li>массовые операции изменения.</li>
</ul>

<p>
  Очень часто это приводит к тому, что часть логики делается в “запросах”,
  часть — в пост-обработке результатов в коде.
  И со временем никто уже не понимает, где именно живёт правило.
</p>

<h3 id="limit-7-sap">SAP</h3>
<p>
  SAP обычно сильнее в запросном слое: SQL, представления, CDS.
  Но появляется другой эффект: уровень “правил” и уровень “данных” часто разделены.
</p>

<p>
  То есть выборка может быть быстрой, но правило может требовать правок в нескольких слоях:
  конфигурация + расширение + аналитическая модель.
</p>

<h3 id="limit-7-dynamics">Dynamics</h3>
<p>
  Dynamics чаще работает через API/ORM/FetchXML (в зависимости от продукта).
  В итоге сложные запросы возможны, но:
</p>
<ul>
  <li>их труднее оптимизировать,</li>
  <li>они дороже в исполнении при больших объёмах,</li>
  <li>часто “побеждает” вариант “выгрузить и посчитать отдельно”.</li>
</ul>

<h3 id="limit-7-odoo">Odoo</h3>
<p>
  Odoo даёт ORM и возможность писать SQL напрямую.
  Но именно смешение двух подходов и является типичной точкой деградации:
</p>
<ul>
  <li>часть команды пишет ORM-логику,</li>
  <li>часть — SQL “для скорости”,</li>
  <li>через год система превращается в гибрид, который трудно сопровождать.</li>
</ul>

<h3 id="limit-7-practice">К чему это приводит</h3>
<ul>
  <li>Правила начинают “жить” в разных слоях (объекты + запросы + обработка результатов).</li>
  <li>Логику тяжело тестировать и объяснять.</li>
  <li>Появляется эффект “не трогать — сломаем отчёты”.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-8-queries-in-strings">Ограничение 8. Запросы в строках</h2>

<p>
  Это один из самых практичных пунктов.
  “Запросы в строках” = запросы становятся <strong>текстом внутри кода</strong>, а не структурой.
</p>

<p>
  Что это ломает:
</p>
<ul>
  <li>рефакторинг,</li>
  <li>поиск зависимостей,</li>
  <li>типизацию и автопроверки,</li>
  <li>статический анализ,</li>
  <li>безопасное изменение логики.</li>
</ul>

<div class="callout">
  <strong>Связь с идеями статей</strong>
  <p>
    Если правила бизнеса выражаются через запросы-строки и “приклеены” к обработчикам,
    система становится хрупкой: одно изменение “правильного текста” может разрушить цепочку отчётов,
    контроля и интеграций.
  </p>
</div>

<h3 id="limit-8-1c">1С</h3>
<p>
  В 1С это прям классический стиль: запрос — это текст, который компонуется строками.
  Отсюда появляются типовые проблемы:
</p>
<ul>
  <li>ошибка всплывает только в рантайме,</li>
  <li>трудно понять, какие поля реально используются,</li>
  <li>запросы копируются и расходятся в версиях,</li>
  <li>логика “размазывается” по отчётам и обработкам.</li>
</ul>

<h3 id="limit-8-sap">SAP</h3>
<p>
  В SAP запросная логика чаще структурирована лучше (SQL/CDS),
  но “запросы в строках” могут появляться в кастомном коде/скриптах/интеграциях.
  Тогда эффект тот же: строка становится источником истины.
</p>

<h3 id="limit-8-dynamics">Dynamics</h3>
<p>
  В Dynamics часто встречается аналогичная проблема, только в другом виде:
  фильтры, условия и запросы формируются через конфигурацию или текстовые выражения
  (зависит от контура).
</p>
<p>
  То есть запрос “живёт” не как модель, а как выражение, которое сложно контролировать.
</p>

<h3 id="limit-8-odoo">Odoo</h3>
<p>
  В Odoo запросы в строках возникают, когда ORM уже не справился,
  и команда начинает вставлять raw SQL “точечно”.
  Это быстро решает задачу, но разрушает единый стиль и поддержку.
</p>

<h3 id="limit-8-practice">К чему это приводит</h3>
<ul>
  <li>Рост числа “неявных зависимостей” между логикой и отчётами.</li>
  <li>Логику сложно делегировать, сложно объяснять и сложно проверять.</li>
  <li>Даже AI-ассистирование становится хуже: строковый запрос без контекста он “угадывает”, а не понимает.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-9-no-query-optimizer">Ограничение 9. Отсутствие оптимизатора запросов</h2>

<p>
  Оптимизатор запросов — это не “гиковский термин”.
  Это то, что определяет, сможет ли система автоматически выбрать:
</p>
<ul>
  <li>правильный план выполнения,</li>
  <li>правильные индексы,</li>
  <li>правильный порядок соединений,</li>
  <li>и не превратит ли отчёт в катастрофу на данных в 10–50 раз больше.</li>
</ul>

<p>
  Если оптимизатор слабый или отсутствует на уровне платформы/языка запросов —
  любая аналитика становится проектом по ручному тюнингу.
</p>

<h3 id="limit-9-1c">1С</h3>
<p>
  В 1С эффект чаще всего выглядит так:
</p>
<ul>
  <li>на тестовой базе всё “летает”,</li>
  <li>на продуктиве внезапно “умирает” проведение или отчёт,</li>
  <li>и начинается бесконечная оптимизация: индексы, переписывание запросов, обходы.</li>
</ul>

<h3 id="limit-9-sap">SAP</h3>
<p>
  SAP опирается на сильные СУБД и обычно выигрывает на стороне оптимизации запросов.
  Но это не означает, что “всё бесплатно”:
</p>
<ul>
  <li>сложность моделей и представлений может создавать тяжёлые планы,</li>
  <li>неочевидные зависимости между слоями усложняют оптимизацию,</li>
  <li>всё равно требуется опытная команда, которая понимает, что происходит.</li>
</ul>

<h3 id="limit-9-dynamics">Dynamics</h3>
<p>
  В Dynamics оптимизация зависит от конкретного контура и способа доступа к данным.
  Типовая проблема:
  когда появляется тяжёлая аналитика или сложные условия,
  проще выгрузить в BI, чем пытаться “выжать” правильный план из платформы.
</p>

<h3 id="limit-9-odoo">Odoo</h3>
<p>
  В Odoo многое зависит от PostgreSQL (он даёт хороший оптимизатор).
  Но эффект возникает на уровне приложения:
</p>
<ul>
  <li>ORM генерирует запросы не всегда оптимально,</li>
  <li>сложные вычисления делаются Python-слоем,</li>
  <li>появляются тяжёлые места без явного “центра оптимизации”.</li>
</ul>

<h3 id="limit-9-practice">К чему это приводит</h3>
<ul>
  <li>Скорость системы становится зависимой от отдельных “магических” запросов.</li>
  <li>Любое изменение рискует сломать производительность, даже если функционально всё правильно.</li>
  <li>Команда начинает избегать улучшений и новых аналитик, потому что боится нагрузки.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-10-no-advanced-sql">Ограничение 10. Отсутствие расширенных SQL возможностей</h2>

<p>
  Под “расширенными возможностями SQL” в статье обычно подразумеваются вещи, которые нужны не ради красоты,
  а ради построения реальной управленческой логики:
</p>

<ul>
  <li>оконные функции (rank, sum over, lag/lead),</li>
  <li>CTE (WITH),</li>
  <li>условные агрегаты,</li>
  <li>нормальная работа с изменениями и версиями данных,</li>
  <li>массовые трансформации без ручных циклов.</li>
</ul>

<p>
  Когда этого нет (или доступно только через сложные обходы),
  всё начинает переноситься в прикладной код.
  А код — это уже другая среда: хуже оптимизация, хуже прозрачность, хуже проверяемость.
</p>

<h3 id="limit-10-1c">1С</h3>
<p>
  В 1С расширенный SQL недоступен напрямую как “естественный инструмент”.
  Поэтому сложные выборки часто превращаются в:
</p>
<ul>
  <li>несколько запросов вместо одного,</li>
  <li>временные таблицы “своими руками”,</li>
  <li>пост-обработку в циклах,</li>
  <li>дубли логики между отчётами.</li>
</ul>

<h3 id="limit-10-sap">SAP</h3>
<p>
  SAP обычно выигрывает: развитые возможности SQL/моделирования есть.
  Но платой становится сложность:
  чтобы “правильно” выразить логику, нужно понимать слой данных и правила стандартных объектов.
</p>

<h3 id="limit-10-dynamics">Dynamics</h3>
<p>
  Dynamics чаще вынужден переносить сложную аналитику в BI-инструменты,
  потому что выразить “богатую” SQL-логику внутри платформы бывает неудобно или дорого.
</p>

<h3 id="limit-10-odoo">Odoo</h3>
<p>
  Odoo на PostgreSQL может использовать расширенный SQL,
  но на практике команда часто боится писать raw SQL массово:
  из-за поддержки, обновлений и “сломаем совместимость”.
  Поэтому снова появляется гибрид: ORM + точечный SQL.
</p>

<h3 id="limit-10-practice">К чему это приводит</h3>
<ul>
  <li>Логика пересчётов расползается по коду и отчётам.</li>
  <li>Система становится менее прозрачной: “где считается этот показатель?”</li>
  <li>Растёт стоимость изменений, потому что нет “единого места”, где это определяется.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-11-no-update-queries">Ограничение 11. Отсутствие запросов на изменение (UPDATE/DELETE/MERGE как класса операций)</h2>

<p>
  Это ограничение обычно выглядит “техническим”, но оно прямо влияет на скорость
  и стоимость сопровождения системы.
</p>

<p>
  В нормальных корпоративных системах есть два типа работы с данными:
</p>
<ul>
  <li><strong>операционная</strong> — когда пользователь делает конкретное действие (провёл документ, изменил заказ, отправил заявку);</li>
  <li><strong>массовая</strong> — когда нужно <strong>безопасно</strong> изменить данные большим объёмом (пересчёт условий, миграция правил, исправление ошибок, очистка, дедупликация).</li>
</ul>

<p>
  Если “массовой” модели нет, остаётся два пути:
</p>
<ul>
  <li>гонять данные в циклах через код (медленно и рискованно),</li>
  <li>лезть напрямую в SQL базы (опасно, требует экспертов, плохо переносится).</li>
</ul>

<div class="callout">
  <strong>Связь с идеями из статей</strong>
  <p>
    Когда правила бизнеса или пересчёты нельзя выразить массово и прозрачно,
    появляется “культ ручных исправлений”: система формально работает,
    но в реальности постоянно нуждается в обслуживании людьми.
  </p>
</div>

<h3 id="limit-11-1c">1С</h3>
<p>
  В 1С типовой паттерн массовых изменений — это обработка + цикл + “перепроведение”.
  Звучит нормально… пока данных мало.
</p>

<ul>
  <li>На больших объёмах это становится медленно.</li>
  <li>Появляются “окна обслуживания ночью”.</li>
  <li>Любой массовый пересчёт становится отдельной инженерной задачей.</li>
</ul>

<h3 id="limit-11-sap">SAP</h3>
<p>
  В SAP массовые изменения обычно возможны, но через другой “налог”:
  сложность модели данных, интерфейсы обновления, права, последствия для транзакционности.
</p>

<p>
  То есть “можно”, но дорого по компетенциям: нужны люди, которые понимают правильный путь изменения данных.
</p>

<h3 id="limit-11-dynamics">Dynamics</h3>
<p>
  В Dynamics массовые изменения чаще уходят в:
</p>
<ul>
  <li>интеграционные пайплайны,</li>
  <li>Power Platform / Dataflows,</li>
  <li>ETL,</li>
  <li>или внешнюю обработку.</li>
</ul>

<p>
  Получается, что “ERP” уже не одна система, а связка из нескольких контуров,
  где часть изменений делается “рядом”.
</p>

<h3 id="limit-11-odoo">Odoo</h3>
<p>
  В Odoo можно делать массовые изменения через SQL/PostgreSQL или через ORM.
  Но если делать через ORM — будет медленно, если через SQL — рискованно по обновлениям и поддержке.
</p>

<p>
  Часто в реальных проектах появляется компромисс:
  “массовые операции только руками и только через техлидов”.
</p>

<h3 id="limit-11-practice">Что это означает для бизнеса</h3>
<ul>
  <li>Нельзя быстро исправить накопленную ошибку или поменять правило “во всём контуре”.</li>
  <li>Любая миграция превращается в проект.</li>
  <li>Рост данных = рост стоимости “обслуживания ERP”.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-12-no-auto-locks">Ограничение 12. Отказ от автоматических блокировок</h2>

<p>
  Здесь речь про многопользовательскую работу:
  когда десятки людей одновременно редактируют связанные данные
  (заказы, остатки, лимиты, оплаты, статусы, согласования).
</p>

<p>
  <strong>Автоматические блокировки</strong> — это когда система сама предотвращает
  конфликтные изменения и гарантирует целостность данных.
</p>

<p>
  Если автоматической модели нет (или она слабая),
  то разработчики вынуждены делать всё вручную:
</p>

<ul>
  <li>ставить блокировки в коде,</li>
  <li>городить “проверку актуальности” перед сохранением,</li>
  <li>обрабатывать конфликты постфактум.</li>
</ul>

<div class="callout">
  <strong>Практический смысл</strong>
  <p>
    Когда блокировки не работают предсказуемо, “ошибки данных” начинают появляться
    без видимой причины: задвоения, расхождения остатков, загадочные состояния документов.
  </p>
</div>

<h3 id="limit-12-1c">1С</h3>
<p>
  В 1С блокировки существуют, но архитектурно многие сценарии решаются “по месту”:
  то есть разработчики “знают”, где нужно ставить контроль и где нельзя допускать гонки.
</p>

<p>
  В итоге часто получается:
</p>
<ul>
  <li>в одном модуле конфликт обработан,</li>
  <li>в другом забыли,</li>
  <li>в третьем “обходной путь” всё равно создаёт риск.</li>
</ul>

<h3 id="limit-12-sap">SAP</h3>
<p>
  SAP в целом сильнее в транзакционной целостности, но цена этого —
  сложность и стоимость сопровождения:
  любое “особое поведение” требует понимания стандартных механизмов и влияния на производительность.
</p>

<h3 id="limit-12-dynamics">Dynamics</h3>
<p>
  В Dynamics конфликтность часто проявляется на уровне интеграций и распределённой логики:
  когда несколько систем меняют один объект в разное время.
</p>

<p>
  В результате возникают:
</p>
<ul>
  <li>гонки обновлений,</li>
  <li>состояния “переехали не туда”,</li>
  <li>и “почему у клиента статус не тот?”.</li>
</ul>

<h3 id="limit-12-odoo">Odoo</h3>
<p>
  Odoo работает поверх PostgreSQL и имеет транзакционность,
  но при активной кастомизации (и особенно при асинхронных задачах)
  появляются конкурентные сценарии, которые команда должна ловить руками.
</p>

<h3 id="limit-12-practice">Что это означает для бизнеса</h3>
<ul>
  <li>Ошибки “появляются сами”, и их сложно воспроизводить.</li>
  <li>Команда тратит время не на развитие, а на “разбор инцидентов”.</li>
  <li>Доверие к данным падает, потому что система ведёт себя непредсказуемо.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-13-forms-split-client-server">Ограничение 13. Формы: отказ от единого потока выполнения (разделение логики на сервер и клиент)</h2>

<p>
  Этот пункт очень важный, потому что он про то,
  <strong>как рождаются “необъяснимые” баги</strong> в интерфейсе ERP.
</p>

<p>
  Когда логика формы разделена между клиентом и сервером,
  у вас появляется два мира:
</p>

<ul>
  <li>на клиенте — “то, что видит пользователь”,</li>
  <li>на сервере — “то, что реально считается и сохраняется”.</li>
</ul>

<p>
  И если архитектура слабая, эти два мира начинают расходиться.
  Пользователь видит одно, данные сохраняются иначе.
</p>

<div class="callout">
  <strong>Как это выглядит в жизни</strong>
  <p>
    “Я нажал — было так. Сохранил — стало по-другому”.
    И дальше начинается расследование: это баг UI, бизнес-логика или интеграция?
  </p>
</div>

<h3 id="limit-13-1c">1С</h3>
<p>
  В 1С эта проблема часто проявляется через события формы и обработчики,
  где часть проверок делается “в интерфейсе”, а часть — в серверной логике.
</p>

<p>
  При росте системы появляется эффект:
  один и тот же бизнес-смысл проверяется в нескольких местах по-разному.
</p>

<h3 id="limit-13-sap">SAP</h3>
<p>
  В SAP исторически много “слоёв” UI-логики (в зависимости от технологии),
  но подход более формализованный:
  UI часто “тонкий”, а правила вынесены в backend/процессы.
</p>

<p>
  Проблема не в разделении как таковом, а в том,
  что любое изменение требует знаний нескольких стеков одновременно.
</p>

<h3 id="limit-13-dynamics">Dynamics</h3>
<p>
  В Dynamics разделение клиент/сервер — практически норма (особенно в кастомизации).
  Там легко сделать так, что:
</p>
<ul>
  <li>клиентский скрипт показывает одно,</li>
  <li>серверный валидатор сохраняет другое,</li>
  <li>интеграция сверху перетирает третье.</li>
</ul>

<h3 id="limit-13-odoo">Odoo</h3>
<p>
  В Odoo UI-логика и backend обычно связаны нормально,
  но при активной кастомизации + сторонних модулях
  всё равно появляется риск “двойных правил” (UI vs backend).
</p>

<h3 id="limit-13-practice">Что это означает для бизнеса</h3>
<ul>
  <li>Ошибки появляются “только у некоторых пользователей”.</li>
  <li>Сложно тестировать изменения: UI и backend ведут себя по-разному.</li>
  <li>Увеличивается стоимость поддержки и обучения сотрудников.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-14-no-sync">Ограничение 14. Формы: отказ от синхронности</h2>

<p>
  Отказ от синхронности обычно объясняется “современностью”:
  UI должен быть быстрым, запросы асинхронными, сервер не должен блокировать интерфейс.
  Всё верно.
</p>

<p>
  Но в ERP есть особенность:
  пользователь часто делает действие, которое обязано быть <strong>точным</strong>,
  а не “примерно потом обновится”.
</p>

<p>
  Поэтому когда интерфейс сильно асинхронный,
  возникают две проблемы:
</p>

<ul>
  <li>пользователь не понимает, что уже сохранено, а что ещё нет,</li>
  <li>система становится трудной для предсказуемых проверок.</li>
</ul>

<div class="callout">
  <strong>Самая частая “боль”</strong>
  <p>
    “Я нажал кнопку, статус изменился, а потом открылось снова и всё откатилось”.
    То есть интерфейс показывает не “истину”, а “предварительное состояние”.
  </p>
</div>

<h3 id="limit-14-1c">1С</h3>
<p>
  В 1С синхронность часто ожидается бизнесом “по умолчанию”:
  провёл — значит провёл. Но если архитектура уходит в асинхронность
  через обмены и обработчики — пользователи теряют доверие к системе.
</p>

<h3 id="limit-14-sap">SAP</h3>
<p>
  В SAP асинхронность обычно проявляется в интеграциях и процессе обработки:
  пользователь может завершить шаг, но фактическая обработка транзакции
  проходит через очередь/процесс/валидатор.
</p>

<p>
  Это решается процессной дисциплиной, но цена —
  сложность и необходимость чётких статусов.
</p>

<h3 id="limit-14-dynamics">Dynamics</h3>
<p>
  В Dynamics асинхронность — частый источник “магии”:
  фоновые задачи, плагины, интеграции.
  Визуально всё “нажалось”, но реальный эффект появится позже.
</p>

<h3 id="limit-14-odoo">Odoo</h3>
<p>
  Odoo может быть достаточно синхронным в базовой логике,
  но если добавляются очереди, внешние сервисы и кастомные процессы —
  появляется та же проблема: статус и данные могут быть “не финальными”.
</p>

<h3 id="limit-14-practice">Что это означает для бизнеса</h3>
<ul>
  <li>Люди перестают доверять статусам (“проведено” ≠ “готово”).</li>
  <li>Появляются ручные проверки и повторные действия (“на всякий случай”).</li>
  <li>Возрастает число операционных ошибок.</li>
</ul>

<hr>

<!-- ===================================================== -->
<h2 id="limit-15-no-wysiwyg">Ограничение 15. Формы: отказ от WYSIWYG (разделение интерфейса на запись и чтение)</h2>

<p>
  WYSIWYG в бизнес-системах — это не “про красоту”.
  Это про то, что интерфейс должен быть:
</p>
<ul>
  <li><strong>предсказуемым</strong> (пользователь видит то, что будет сохранено),</li>
  <li><strong>единым</strong> (форма отражает данные одинаково во всех режимах),</li>
  <li><strong>управляемым</strong> (логика не дублируется).</li>
</ul>

<p>
  Когда интерфейс разделён на режимы “чтение” и “запись” так,
  что они ведут себя как два разных экрана —
  появляется серьёзная проблема: <strong>пользователь работает в двух реальностях</strong>.
</p>

<div class="callout">
  <strong>Как это проявляется</strong>
  <p>
    В режиме просмотра всё выглядит правильно,
    но при редактировании появляются другие поля, другие значения, другие правила.
    И сотрудники начинают “бояться редактировать”, чтобы не сломать документ.
  </p>
</div>

<h3 id="limit-15-1c">1С</h3>
<p>
  В 1С такое разделение чаще проявляется через усложнение форм:
  разные режимы, разные события, разные проверки.
  В итоге редактирование превращается в отдельную механику.
</p>

<h3 id="limit-15-sap">SAP</h3>
<p>
  В SAP UI обычно более “процессный”:
  пользователь двигается по шагам.
  Это может быть удобно, но риски появляются, когда данные редактируются через несколько UI-уровней
  с разными правилами доступа и отображения.
</p>

<h3 id="limit-15-dynamics">Dynamics</h3>
<p>
  В Dynamics часто возникает эффект “форма-конфигуратор”:
  чтение и редактирование реально ощущаются по-разному,
  потому что часть полей вычисляется или подгружается асинхронно.
</p>

<h3 id="limit-15-odoo">Odoo</h3>
<p>
  В Odoo базово UI достаточно согласован,
  но при “зоопарке модулей” и кастомизации
  можно получить “разные формы одной сущности”,
  которые ведут себя по-разному.
</p>

<h3 id="limit-15-practice">Что это означает для бизнеса</h3>
<ul>
  <li>Ошибки редактирования превращаются в отдельный класс инцидентов.</li>
  <li>Сотрудники избегают корректировок и начинают делать “обходы”.</li>
  <li>Рост затрат на обучение и поддержку.</li>
</ul>



</section>


              

              <hr>

              <h2 id="sources">Источники и ссылки</h2>
              <ul>
                <li>
                  Исходная идея, по мотивам которой сделан разбор:
                  <a href="https://habr.com/ru/companies/lsfusion/articles/544982/" target="_blank" rel="noopener noreferrer">
                    “ERP, которая не ломается от изменений” (Хабр) ↗
                  </a>
                </li>
              </ul>

              <h2 id="related-posts">Похожие статьи</h2>
              <div class="callout">
                <strong>Продолжить чтение:</strong>
                <p>
                  Если вам важно снизить зависимость от подрядчиков и понять, где на практике теряются деньги в ERP-контуре — вот ещё материалы:
                </p>
                <ul>
                   <li>
                  Базовый обзор open-source ERP и low-code подходов (EN):
                  <a href="https://ru.devlab.blog/posts/post13-open-source-erp-low-code.html" target="_blank" rel="noopener noreferrer">
                     Open-source ERP и low-code: какие бизнес-системы реально используют компании ↗
                  </a>
                </li>
                <li>
                  Контекст про будущие ERP-стэки и “читабельность логики” (Main):
                  <a href="https://ru.devlab.blog/main-erp-stack-2032-ai-readable-architectures.html" target="_blank" rel="noopener noreferrer">
                    Почему ERP будущего будут модульными, декларативными и читаемыми для ИИ ↗
                  </a>
                </li>
                </ul>
              </div>
            </section>

            <footer class="post-footer-extended">
              <div class="post-footer-meta">
                <div class="post-meta-tags">
                  <span class="post-tag">ERP</span>
                  <span class="post-tag">Управление изменениями</span>
                  <span class="post-tag">1С</span>
                  <span class="post-tag">SAP</span>
                  <span class="post-tag">Dynamics</span>
                  <span class="post-tag">Odoo</span>
                  <span class="post-tag">Интеграции</span>
                  <span class="post-tag">Vendor lock-in</span>
                  <span class="post-tag">Low-code</span>
                </div>

                <div class="post-meta-secondary">
                  <span>Опубликовано: 22 янв 2026</span>
                  <span>·</span>
                  <span>Примерно 10–12 мин чтения</span>
                  <span>·</span>
                  <span class="post-views">Просмотры: <span class="count">—</span></span>
                </div>
              </div>
            </footer>

            <!-- Inline newsletter -->
            <section class="sidebar-block">
              <p class="sidebar-text">
                Без спама — только редкие заметки про ERP, автоматизацию и новые статьи.
              </p>
              <form class="newsletter-form"
                    action="https://formsubmit.co/info@devlab.blog"
                    method="POST">
                <input type="hidden" name="_next" value="https://ru.devlab.blog/thank-you.html">
                <input type="hidden" name="_captcha" value="false">
                <input type="text" name="_honey" style="display:none">

                <input type="email" name="email" class="field" placeholder="Ваш email" required>
                <button class="btn btn-primary" type="submit">Подписаться</button>

                <p class="newsletter-note">
                  Вы получите письмо подтверждения.<br>
                  Работает через FormSubmit.
                </p>
              </form>

              <h2 id="feedback">Быстрый фидбек</h2>
              <div class="callout">
                <strong>Было полезно?</strong>
                <p>Короткий сигнал помогает нам выбирать следующие темы.</p>

                <div class="hero-actions">
                  <button class="btn btn-primary" type="button" data-vote="like">
                    👍 Да <span class="count" data-count="like">—</span>
                  </button>

                  <button class="btn btn-outline" type="button" data-vote="dislike">
                    👎 Не особо <span class="count" data-count="dislike">—</span>
                  </button>
                </div>

                <p class="sidebar-text">Без комментариев и аккаунтов.</p>
              </div>
            </section>

            <div class="post-nav-links">
              <a class="back" href="/#posts" style="margin-left: 0;">← Назад ко всем статьям</a>
              <a class="back" href="/#categories" style="margin-right: 0;">Категории →</a>
            </div>
          </article>

          <!-- SIDEBAR -->
          <aside class="sidebar">
            <section class="sidebar-block">
              <h3 class="sidebar-title" id="topic-question-title">Предложить тему</h3>
              <p class="sidebar-text">
                Есть вопрос или идея для следующей статьи?
                <a class="post-read" href="mailto:info@devlab.blog?subject=Идея%20или%20вопрос%20для%20DevLab%20Blog">
                  Написать нам →
                </a>
              </p>
            </section>

            <section class="sidebar-block">
              <h3 class="sidebar-title">О блоге</h3>
              <p class="sidebar-text">
                DevLab Blog — заметки про open-source ERP, модульные подходы, интеграции и практику автоматизации.
                Пишем про то, что ломается в реальных внедрениях и как принимать технологические решения без “религии”.
              </p>
            </section>

            <section class="sidebar-block">
              <h3 class="sidebar-title">Ещё</h3>
              <p class="sidebar-text">
                Вернитесь на главную страницу или выберите категорию:
              </p>
              <ul>
                <li><a href="/">Все статьи</a></li>
                <li><a href="/#categories">Категории</a></li>
                <li><a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Главный сайт DevLab</a></li>
              </ul>
            </section>
          </aside>
        </div>
      </div>
    </main>


    <!-- FOOTER -->
    <footer class="site-footer">
      <div class="wrapper footer-grid">
        <div>
          <div class="footer-links">
            <a href="/">Статьи</a>
            <a href="/#categories">Категории</a>
            <a href="/#about">О блоге</a>
            <a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Главный сайт</a>
          </div>
          <p class="footer-meta">
            DevLab Blog – заметки про open-source ERP, модульные архитектуры и автоматизацию.
          </p>
        </div>
        <div class="footer-meta">
          <p>&copy; <span id="year"></span> DevLab Blog</p>
        </div>
      </div>
    </footer>
  </div>
</body>
</html>
